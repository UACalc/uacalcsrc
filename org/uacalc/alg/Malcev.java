/* Malcev.java 2001/09/02  */

package org.uacalc.alg;

import java.util.*;

import org.uacalc.ui.tm.ProgressReport;
import org.uacalc.util.*;
import org.uacalc.terms.*;
import org.uacalc.alg.conlat.*;
import org.uacalc.alg.sublat.*;
import org.uacalc.alg.op.*;
//import org.apache.log4j.*;
import java.util.logging.*;

/**
 * A class with static methods for Mal'cev conditions such as finding
 * Jonsson terms, etc. It also has methods for related things such as
 * finding a near unamimity term of a given arity, finding a near 
 * majority term, etc.
 *
 * @version $Id$
 */
public class Malcev {

  //static Logger logger = Logger.getLogger("org.uacalc.alg.Malcev");
  //static {
  //  logger.setLevel(Level.FINER);
  //}
  //static ProgressReport monitor;

  // make sure the class cannot be instantiated.
  private Malcev() {}

  //public static Monitor getMonitor() { return monitor; }
  //public static void setMonitor(ProgressReport m) { monitor = m; }
  
  /**
   * Gives a Kearnes-Kiss join term. See their monograph, chapter 3.
   * 
   */
  public static Term joinTerm(SmallAlgebra alg) {
    return joinTerm(alg, null);
  }
  
  /**
   * Gives a Kearnes-Kiss join term. See their monograph, chapter 3.
   * 
   */
  public static Term joinTerm(SmallAlgebra alg, ProgressReport report) {
    if (alg.cardinality() == 1)  return Variable.x;
    final Term taylor = markovicMcKenzieSiggersTaylorTerm(alg, report);
    final Map<Variable,Term> map = new HashMap<Variable,Term>(4);
    final Variable x0 = new VariableImp("x0");
    final Variable x1 = new VariableImp("x1");
    final Variable x2 = new VariableImp("x2");
    final Variable x3 = new VariableImp("x3");
    map.put(x0, Variable.x);
    map.put(x1, Variable.x);
    map.put(x2, Variable.y);
    map.put(x3, Variable.y);
    final Term t0 = taylor.substitute(map);
    
    map.put(x0, Variable.x);
    map.put(x1, Variable.x);
    map.put(x2, Variable.y);
    map.put(x3, Variable.x);
    final Term t1 = taylor.substitute(map);
    
    map.put(x0, Variable.y);
    map.put(x1, Variable.x);
    map.put(x2, Variable.x);
    map.put(x3, Variable.x);
    final Term t2 = taylor.substitute(map);
    
    final Term t3 = t2;
    
    map.put(x0, t0);
    map.put(x1, t1);
    map.put(x2, t2);
    map.put(x3, t3);
    // TODO: need to simplify this term !!!!!!!!!!!!!
    return taylor.substitute(map);
  }
  
  private static int involutionAuto(int i, FreeAlgebra f2, Map<Integer,Integer> auto) {
    if (auto.get(i) == null) {
      Map<Term,Integer> substMap = new HashMap<Term,Integer>(2);
      substMap.put(Variable.x, 1); // 1 is the y generator
      substMap.put(Variable.y, 0);
      Term t = f2.getTerm((IntArray)f2.getElement(i));
      auto.put(i, t.intEval(f2, substMap));
    }
    return auto.get(i); 
  }
  
  /**
   * If the variety generated by alg is congruence SD-meet, this returns 
   * a list of either one or three 3-place terms. If there are three, 
   * r, s, and t. s is a wnu term and they 
   * satisfy r(xxy) = r(xyx) = t(xyx) = t(yxx) = s(xxy)
   * and r(yxx) = t(yyx). 
   * 
   * @param alg
   * @return
   */
  public static List<Term> sdmeetTerms(SmallAlgebra alg) {
    return  sdmeetTerms(alg, null);
  }
  
  /**
   * If the variety generated by alg is congruence SD-meet, this returns 
   * a list of either one or three 3-place terms. If there are three, 
   * r, s, and t. s is a wnu term and they 
   * satisfy r(xxy) = r(xyx) = t(xyx) = t(yxx) = s(xxy)
   * and r(yxx) = t(yyx). 
   * 
   */
  public static List<Term> sdmeetTerms(SmallAlgebra alg, ProgressReport report) {
    if (alg.cardinality() == 1) {
      List<Term> ans = new ArrayList<Term>(1);
      ans.add(Variable.x);
      return ans;
    }
    if (alg.isIdempotent()) {
      if (sdMeetIdempotent(alg, report) != null) {
        return null;
      }
    }
    if (report != null) report.addStartLine(
        "computing the subalgebra of F(2)^3 generated by (x,x,y) (x,y,x), (y,x,x).");
    List<Term> ans = new ArrayList<Term>(3);
    final boolean isIdempotent = alg.isIdempotent();
    // if idempotent add the polynomial times test.
    FreeAlgebra f2 = new FreeAlgebra(alg, 2, report);
    Operation autoXY = f2.switchXandYAutomorphism();
    // ** Need to put in a test if the tables will fit in memory. **
    f2.makeOperationTables();
    IntArray g0 = new IntArray(new int[] {0,0,1,0});
    IntArray g1 = new IntArray(new int[] {0,1,0,0});
    IntArray g2 = new IntArray(new int[] {1,0,0,0});
    List<IntArray> gens = new ArrayList<IntArray>(3);
    gens.add(g0);
    gens.add(g1);
    gens.add(g2);
    final Map<IntArray,Term> termMap = new HashMap<IntArray,Term>(3);
    termMap.put(g0, new VariableImp("x"));
    termMap.put(g1, new VariableImp("y"));
    termMap.put(g2, new VariableImp("z"));
    BigProductAlgebra f2pow = new BigProductAlgebra(f2, 4);
    Closer closer = new Closer(f2pow, gens, termMap);
    closer.setProgressReport(report);  
    List<IntArray> univ = closer.sgClosePower();
    List<IntArray> univX; // members of univ with last coordinate x
    if (isIdempotent) {
      univX = univ;
    }
    else {
      univX = new ArrayList<IntArray>();
      for (IntArray ia : univ) {
        if (ia.get(3) == 0) univX.add(ia);  // 0 means it's x
      }
    }
    // a TreeMap might be a better choice
    Map<Integer,IntArray> aaaMap = new HashMap<Integer,IntArray>();
    Map<Integer,Map<Integer,IntArray>> aabMap = new HashMap<Integer,Map<Integer,IntArray>>();
    Map<Integer,Map<Integer,IntArray>> caaMap = new HashMap<Integer,Map<Integer,IntArray>>();
    for (IntArray ia : univX) {
      if (ia.get(0) == ia.get(1)) {
        if (ia.get(1) == ia.get(2)) { // so ia looks like aaax
          if (ia.get(0) == autoXY.intValueAt(ia.get(0))) { // if a is invariant under x <--> y on F(x,y)
            ans.add(termMap.get(ia));
            if (report != null) {
              report.addLine("found a weak nu term with s(x,x,y) = s(y,x,x)");
              report.addLine("this cannot be modelled in modules so give SD-meet");
              report.addEndingLine("This algebra's variety is congruence SD-meet");
            }
            return ans; 
          }
          aaaMap.put(ia.get(0), ia);
        }
        Map<Integer,IntArray> bMap = aabMap.get(ia.get(0));
        if (bMap == null) {
          bMap = new HashMap<Integer,IntArray>();
          aabMap.put(ia.get(0), bMap);
        }
        bMap.put(ia.get(2), ia);
      }
      if (ia.get(1) == ia.get(2)) {
        Map<Integer,IntArray> cMap = caaMap.get(ia.get(2));
        if (cMap == null) {
          cMap = new HashMap<Integer,IntArray>();
          caaMap.put(ia.get(2), cMap);
        }
        cMap.put(ia.get(0), ia);
      }
    }
    for (Integer a : aaaMap.keySet()) {
      for (int b : aabMap.get(a).keySet()) {
        int c = autoXY.intValueAt(b);  // do we need to use an array [b] ?
        if (caaMap.get(a) != null && caaMap.get(a).get(c) != null) {
          System.out.println("a: " + a + " b: " + b + " c: " + c);
          Map<IntArray,Term> f2TM = f2.getTermMap();
          System.out.println("a: " + f2TM.get(f2.getElement(a)));
          System.out.println("b: " + f2TM.get(f2.getElement(b)));
          System.out.println("c: " + f2TM.get(f2.getElement(c)));
          System.out.println("a: " + aaaMap.get(a));
          System.out.println("aab: " + aabMap.get(a).get(b));
          System.out.println("caa: " + caaMap.get(a).get(c));
          ans.add(termMap.get(aabMap.get(a).get(b)));
          ans.add(termMap.get(aaaMap.get(a)));
          ans.add(termMap.get(caaMap.get(a).get(c)));
          if (report != null) {
            report.addLine("found Kozik-Valeriote-Maroti-Janko terms:");
            report.addLine("idempotent terms r, s and t with s a weak nu term and");
            report.addLine("r(x,x,y) = r(x,y,x) = t(x,y,x) = t(y,x,x) = s(x,x,y)");
            report.addLine(" and r(y,x,x) = t(y,y,x)");
            report.addLine("these cannot be modelled in modules so give SD-meet");
            report.addEndingLine("This algebra's variety is congruence SD-meet");
          }
          return ans;
        }
      }
    }
    return null;
  }
  
  /**
   * This uses Theorem 4.3 of Freese-Valeriote to test if the 
   * algebra omits type 1 and 2; that is, is congruence SDmeet.
   * It returns the x and y witnessing the failure or null if
   * there is no failure.
   * 
   * @param alg  the algebra, assumed to be idempotent
   * @param report
   * @return x and y in alg that witness the failure or null if there is none
   */
  public static IntArray sdMeetIdempotent(SmallAlgebra alg, ProgressReport report) {
    if (report != null) {
      report.addStartLine("Using Thm 4.3 of Freese-Valeriote to test if V(A) is SD-meet");
    }
    final int n = alg.cardinality();
    final BigProductAlgebra sq = new BigProductAlgebra(alg, 2);
    final IntArray a = new IntArray(2);
    final IntArray b = new IntArray(2);
    final IntArray c = new IntArray(2);
    final List<IntArray> gens = new ArrayList<IntArray>(3);
    gens.add(a);
    gens.add(b);
    gens.add(c);
    for (int x = 0; x < n; x++) {
      for (int y = 0; y < n; y++) {
        if (x == y) continue;
        a.set(0, x);
        a.set(1, x);
        b.set(0, x);
        b.set(1, y);
        c.set(0, y);
        c.set(1, x);
        final SmallAlgebra sub = new SubProductAlgebra("", sq, gens);
        final int aIndex = sub.elementIndex(a);
        final int bIndex = sub.elementIndex(b);
        final int cIndex = sub.elementIndex(c);
        Partition alpha = sub.con().Cg(aIndex, cIndex);
        Partition beta = sub.con().Cg(aIndex, bIndex);
        Partition gamma = sub.con().Cg(bIndex, cIndex);
        if (!alpha.meet(beta).join(gamma).meet(alpha).join(beta).isRelated(aIndex, cIndex)) {
          if (report != null) {
            report.setWitnessAlgebra(new AlgebraWithGeneratingVector(sub, 
                new int[] {aIndex, bIndex, cIndex}));
            report.addLine("Found a failure of Theorem 4.3 of Freese-Valeriote");
            report.addLine("with x = " + x + ", y = " + y);
            report.addLine("This algebra admits either type 1 or 2.");
            report.addEndingLine("So this algebra does not generate an SD-meet variety"); 
          }
          return new IntArray(new int[] {x, y});
        }
      }
    }
    if (report != null) {
      report.addEndingLine("V(A) is congruence SD-meet.");
    }
    return null;
  }
  
  
  
  /**
   * Gives a term t(x,y,z,u) satisfying t(y,x,x,x) = t(x,x,y,y) and
   * t(x,x,y,x) = t(x,y,x,x).
   * 
   */
  public static Term markovicMcKenzieSiggersTaylorTerm(SmallAlgebra alg) {
    return markovicMcKenzieSiggersTaylorTerm(alg, null);
  }
  
  /**
   * Gives a term t(x,y,z,u) satisfying t(y,x,x,x) = t(x,x,y,y) and
   * t(x,x,y,x) = t(x,y,x,x).
   * 
   */
  public static Term markovicMcKenzieSiggersTaylorTerm(SmallAlgebra alg, 
                                                       ProgressReport report) {
    
    if (alg.cardinality() == 1)  return Variable.x;
    final boolean isIdempotent = alg.isIdempotent();
    final int[][] blocks = new int[][] {{0,1},{2,3}};
    final int[][] values = new int[][] {{4,0}};
    FreeAlgebra f2 = new FreeAlgebra(alg, 2, report);
    // ** Need to put in a test if the tables will fit in memory. **
    f2.makeOperationTables();
    //logger.info("f2 size is " + f2.cardinality());
    IntArray g0;
    IntArray g1;
    IntArray g2;
    IntArray g3;
    if (isIdempotent) {
      g0 = new IntArray(new int[] {1,0,0,0});
      g1 = new IntArray(new int[] {0,0,0,1});
      g2 = new IntArray(new int[] {0,1,1,0});
      g3 = new IntArray(new int[] {0,1,0,0});
    }
    else {
      g0 = new IntArray(new int[] {1,0,0,0,0});
      g1 = new IntArray(new int[] {0,0,0,1,0});
      g2 = new IntArray(new int[] {0,1,1,0,0});
      g3 = new IntArray(new int[] {0,1,0,0,0});
    }
    List<IntArray> gens = new ArrayList<IntArray>(4);
    gens.add(g0);
    gens.add(g1);
    gens.add(g2);
    gens.add(g3);
    final Map<IntArray,Term> termMap = new HashMap<IntArray,Term>(4);
    termMap.put(g0, new VariableImp("x0"));
    termMap.put(g1, new VariableImp("x1"));
    termMap.put(g2, new VariableImp("x2"));
    termMap.put(g3, new VariableImp("x3"));
    //final IntArray yx = new IntArray(new int[] {1,0});
    BigProductAlgebra f2pow;
    if (isIdempotent) {
      f2pow = new BigProductAlgebra(f2, 4);
    }
    else {
      f2pow = new BigProductAlgebra(f2, 5);
    }
    Closer closer = new Closer(f2pow, gens, termMap);
    closer.setProgressReport(report);
    closer.setBlocks(blocks);
    if (!isIdempotent) closer.setValues(values);
    closer.sgClosePower();
    if (closer.getElementToFind() != null) {
      return termMap.get(closer.getElementToFind());
    }
    
    /*
    List sub = f2pow.sgClose(gens, termMap);
    //logger.info("sub alg of the " + (isIdempotent ? "third" : "fourth")
    //   + " power of f2 size " + sub.size());
    IntArray ia = null;
    for (Iterator it = sub.iterator(); it.hasNext(); ) {
      ia = (IntArray)it.next();
      if (ia.get(0) == ia.get(1) && ia.get(2) == ia.get(3)) {
        if (isIdempotent) break;
        if (ia.get(4) == 0) break; // last coord is x
      }
      ia = null;
    }
    if (ia != null) return (Term)termMap.get(ia);
    */
    return null;
  }

  /**
   * A finitely generated variety has a Taylor term if and 
   * only if it has a weak 3-edge term.
   * See K. Kearnes, P. Markovic, and R. McKenzie,  
   * Optimal strong Mal'cev conditions for omitting type 1 in locally finite varieties,
   * Algebra Universalis, to appear. 
   * 
   * @param alg
   * @param report
   * @return
   */
  public static Term weak3EdgeTerm(SmallAlgebra alg, ProgressReport report) {
    if (alg.cardinality() == 1)  return Variable.x;
    if (report != null) report.addStartLine(
        "Looking for a weak 3-edge term: e(y,y,x,x) = e(y,x,y,x) = e(x,x,x,y).");
    final boolean isIdempotent = alg.isIdempotent();
    final int[][] blocks = new int[][] {{0,1,2}};
    final int[][] values = new int[][] {{3,0}};
    FreeAlgebra f2 = new FreeAlgebra(alg, 2, report);
    // ** Need to put in a test if the tables will fit in memory. **
    f2.makeOperationTables();
    //logger.info("f2 size is " + f2.cardinality());
    IntArray g0;
    IntArray g1;
    IntArray g2;
    IntArray g3;
    if (isIdempotent) {
      g0 = new IntArray(new int[] {1,1,0});
      g1 = new IntArray(new int[] {1,0,0});
      g2 = new IntArray(new int[] {0,1,0});
      g3 = new IntArray(new int[] {0,0,1});
    }
    else {
      g0 = new IntArray(new int[] {1,1,0,0});
      g1 = new IntArray(new int[] {1,0,0,0});
      g2 = new IntArray(new int[] {0,1,0,0});
      g3 = new IntArray(new int[] {0,0,1,0});
    }
    List<IntArray> gens = new ArrayList<IntArray>(4);
    gens.add(g0);
    gens.add(g1);
    gens.add(g2);
    gens.add(g3);
    final Map<IntArray,Term> termMap = new HashMap<IntArray,Term>(4);
    termMap.put(g0, new VariableImp("x0"));
    termMap.put(g1, new VariableImp("x1"));
    termMap.put(g2, new VariableImp("x2"));
    termMap.put(g3, new VariableImp("x3"));
    //final IntArray yx = new IntArray(new int[] {1,0});
    BigProductAlgebra f2pow;
    if (isIdempotent) {
      f2pow = new BigProductAlgebra(f2, 3);
    }
    else {
      f2pow = new BigProductAlgebra(f2, 4);
    }
    Closer closer = new Closer(f2pow, gens, termMap);
    closer.setProgressReport(report);
    closer.setBlocks(blocks);
    if (!isIdempotent) closer.setValues(values);
    closer.sgClosePower();
    if (closer.getElementToFind() != null) {
      Term w3edge = termMap.get(closer.getElementToFind());
      if (report != null) report.addEndingLine("found a weak 3-edge term: " + w3edge);
      return w3edge;
    }
    if (report != null) report.addEndingLine("there is no weak 3-edge term: ");
    return null;
  }
    
  
  
  /**
   * This will find a near unamimity term of the given arity
   * if one exits; otherwise it return <tt>null</tt>.
   */
  public static Term nuTerm(SmallAlgebra alg, int arity) {
    return nuTerm(alg, arity, null);
  }
  
  /**
   * This will find a near unanimity term of the given arity
   * if one exits; otherwise it return <tt>null</tt>.
   */
  public static Term nuTerm(SmallAlgebra alg, int arity, ProgressReport report) {
    if (alg.cardinality() == 1) return new VariableImp("x0");
    if (alg.isIdempotent()) {
      if (!isCongruenceDistIdempotent(alg, report)) return null;
      if (report != null) {
        // may want to add a test for distributivity here.
        report.addStartLine("Using Horitz's algorithm to if an NU term exists");
      }
      if (!nuTermIdempotent(alg, arity, report)) {
        if (report != null) {
          report.addEndingLine("Done: there is no NU term of arity " + arity);
        }
        return null;
      }
      if (report != null) {
        report.addEndingLine("There is an NU term of arity " + arity);
      }
    }
    if (report != null) report.addStartLine("Finding an NU term:");
    FreeAlgebra f2 = new FreeAlgebra(alg, 2, report);
 // ** Need to put in a test if the tables will fit in memory. **
    f2.makeOperationTables();
    final List<IntArray> gens = new ArrayList<IntArray>(arity);
    final Map<IntArray,Term> termMap = new HashMap<IntArray,Term>();
    for (int i = 0; i < arity ; i++) {
      final int[] arr = new int[arity];
      arr[i] = 1;
      IntArray ia = new IntArray(arr);
      gens.add(ia);
      Variable var = arity > 3 ? new VariableImp("x" + i) : null;
      if (var == null) {
        if (i == 0) var = Variable.x;
        else if (i == 1) var = Variable.y;
        else var = Variable.z;
      }
      termMap.put(ia, var);
    }
    BigProductAlgebra f2power = new BigProductAlgebra(f2, arity);
    final IntArray zero = new IntArray(new int[arity]);
    if (report != null) report.addStartLine("looking for (x,x,...x) in Sg_F(2)^" + arity 
        + " generated by (y,x,x...,x), (x,y,x,...,x), ...");
    List<IntArray> sub = f2power.sgClose(gens, termMap, zero, report);
    if (sub.contains(zero)) {
      if (report != null) {
        report.addEndingLine("found (x,x,...x)");
        report.addEndingLine("done find the NU term.");
      }
      return termMap.get(zero);
    }
    if (report != null) {
      report.addEndingLine("could not find (x,x,...x)");
      report.addEndingLine("done find the NU term.");
    }
    return null;
  }

  /**
   * Matt Valeriote's implementation of Jonah Horowitz's polynomial
   * time algorithm to test if an idempotent algebra has an NU term
   * of <code>arity</code> variables.
   * 
   * @param testalg  an idempotent algebra
   * @param arity
   * @return
   */
  public static boolean nuTermIdempotent_Bad(SmallAlgebra testalg, int arity, ProgressReport report) {
    if (arity < 3) throw new IllegalArgumentException("arity must be at least 3");
    if (report != null) report.addStartLine("Using Horowitz's algorithm to test for a " + arity + "-ary NU."); 
    int power = arity;
    BigProductAlgebra alg = new BigProductAlgebra(testalg, power);
    final int size = testalg.cardinality();
    //IntArray genvector = new IntArray(arity);
    int[] A = new int[arity];
    int[] B = new int[arity];
    int[][] G = new int[arity][arity];
    for (int i = 0; i < arity; i++) {
      A[i] = 0;
    }
    ArrayIncrementor Ainc = SequenceGenerator.sequenceIncrementor(A, size - 1);
    while (true) {
      IntArray Aarray = new IntArray(A);
      for (int i = 0; i < arity; i++) {
        B[i] = 0;
      }
      ArrayIncrementor Binc = SequenceGenerator.sequenceIncrementor(B, size - 2);
      while (true) {
        List<IntArray> gens = new ArrayList<IntArray>(arity);
        for (int j = 0; j < arity; j++) {
          for (int k = 0; k < arity; k++) {
            if (j == k) {
              if (B[j] == A[j]) {
                G[j][k] = B[j] + 1;
              } else {
                G[j][k] = B[j];
              }
            } else {
              G[j][k] = A[k];
            }
          }
          gens.add(new IntArray(G[j]));
        }
        List<IntArray> sub = alg.sgClose(gens, null, Aarray, null);
        if (!sub.contains(Aarray)) {
          String Astring = Arrays.toString(A);
          if (report != null) {
            report.addLine("The tuple " + Astring + " is not in the "
                + "subuniverse generated by the tuples:");
            for (int k = 0; k < arity; k++) {
              String GenString = Arrays.toString(G[k]);
              report.addLine(GenString);
            }
            report.addEndingLine("There is no " + arity + "-ary NU.");
          }
          //System.out.println("The subuniverse is " + sub.toString());
          return false;
        }
        if (!Binc.increment()) break;
      }
      if (!Ainc.increment()) break;
    }
    if (report != null) report.addEndingLine("There is a " + arity + "-ary NU.");
    return true;
  }
  
  /**
   * Matt Valeriote's implementation of Jonah Horowitz's polynomial
   * time algorithm to test if an idempotent algebra has an NU term
   * of <code>arity</code> variables.
   * 
   * @param testalg  an idempotent algebra
   * @param arity
   * @return
   */
  public static boolean nuTermIdempotent(SmallAlgebra testalg, int arity, ProgressReport report) {
    if (arity < 3) throw new IllegalArgumentException("arity must be at least 3");
    if (report != null) report.addStartLine("Using Horowitz's algorithm to test for a " + arity + "-ary NU."); 
    int power = arity;
    BigProductAlgebra alg = new BigProductAlgebra(testalg, power);
    final int size = testalg.cardinality();
    //IntArray genvector = new IntArray(arity);
    int[] A = new int[arity];
    int[] B = new int[arity];
    int[][] G = new int[arity][arity];
    for (int i = 0; i < arity; i++) {
      A[i] = 0;
    }
    ArrayIncrementor Ainc = SequenceGenerator.nondecreasingSequenceIncrementor(A, size - 1);
    while (true) {
      IntArray Aarray = new IntArray(A);
      for (int i = 0; i < arity; i++) {
        B[i] = 0;
      }
      ArrayIncrementor Binc = SequenceGenerator.sequenceIncrementor(B, size - 2);
      while (true) {
        List<IntArray> gens = new ArrayList<IntArray>(arity);
        for (int j = 0; j < arity; j++) {
          for (int k = 0; k < arity; k++) {
            if (j == k) {
              if (B[j] >= A[j]) { // this used to be ==, but B should increase whenever it is >= A
                G[j][k] = B[j] + 1;
              } else {
                G[j][k] = B[j];
              }
            } else {
              G[j][k] = A[k];
            }
          }
          gens.add(new IntArray(G[j]));
        }
        //System.out.println("gens: " + gens);
        //System.out.println("Aaar: " + Aarray);
        Closer closer = new Closer(alg, gens);
        closer.setElementToFind(Aarray);
        closer.setSuppressOutput(true);
        //List<IntArray> sub = alg.sgClose(gens, null, Aarray, null); //add null field to turn off report
        List<IntArray> sub = closer.sgClose();
        if (!sub.contains(Aarray)) {
          String Astring = Arrays.toString(A);
          if (report != null) {
            report.addLine("The tuple " + Astring + " is not in the "
                + "subuniverse generated by the tuples:");
            for (int k = 0; k < arity; k++) {
              String GenString = Arrays.toString(G[k]);
              report.addLine(GenString);
            }
            report.addEndingLine("There is no " + arity + "-ary NU.");
          }
          else {
            System.out.println("The tuple " + Astring + " is not in the "
                + "subuniverse generated by the tuples:");
            for (int k = 0; k < arity; k++) {
              String GenString = Arrays.toString(G[k]);
              System.out.println(GenString);
            }
            System.out.println("The subuniverse is " + sub.toString());
          }
          return false;
        }
        if (!Binc.increment()) {
          break;
        }
      }
      if (!Ainc.increment()) {
        break;
      }
    }
    if (report != null) report.addEndingLine("There is a " + arity + "-ary NU.");
    return true;
  }

  
  /**
   * This will find a near unamimity term of the given arity
   * if one exits; otherwise it return <tt>null</tt>.
   */
  public static Term weakNUTerm(SmallAlgebra alg, int arity) {
    return findWeakNUTerm(alg, arity, null);
  }
  
  /**
   * This will find a near unanimity term of the given arity
   * if one exits; otherwise it return <tt>null</tt>.
   */
  public static Term findWeakNUTerm(SmallAlgebra alg, int arity, ProgressReport report) {
    if (alg.cardinality() == 1) return new VariableImp("x0");
    final boolean isIdempotent = alg.isIdempotent();
    FreeAlgebra f2 = new FreeAlgebra(alg, 2, report);
 // ** Need to put in a test if the tables will fit in memory. **
    //f2.makeOperationTables();
    final int pow = isIdempotent ? arity : arity + 1;
    int[][] blocks = new int[1][];
    blocks[0] = new int[arity];
    final List<IntArray> gens = new ArrayList<IntArray>(arity);
    final Map<IntArray,Term> termMap = new HashMap<IntArray,Term>();
    for (int i = 0; i < arity ; i++) {
      final int[] arr = new int[pow]; 
      arr[i] = 1;
      IntArray ia = new IntArray(arr);
      gens.add(ia);
      Variable var = arity > 3 ? new VariableImp("x" + i) : null;
      if (var == null) {
        if (i == 0) var = Variable.x;
        else if (i == 1) var = Variable.y;
        else var = Variable.z;
      }
      termMap.put(ia, var);
      blocks[0][i] = i;
    }
    if (report != null) report.addStartLine("looking for " + arity + "-ary weak nu term");
    BigProductAlgebra f2power = new BigProductAlgebra(f2, pow);
    Closer closer = new Closer(f2power, gens, termMap);
    closer.setProgressReport(report);
    closer.setBlocks(blocks);
    if (!isIdempotent) {
      closer.setValues(new int[][] {{arity,0}});
    }
    List<IntArray> lst = closer.sgClosePower();
    System.out.println("found: " + lst.size());
    final boolean found = closer.getElementToFind() != null;
    if (!found) {
      if (report != null) report.addEndingLine("there is no " + arity + "-ary wnu");
      return null;
    }
    if (report != null) 
      report.addEndingLine("there is a " + arity + "-ary wnu: " + termMap.get(closer.getElementToFind()));
    return termMap.get(closer.getElementToFind());
  }

  
  
  
  /**
   * If \alpha = Cg(a,c) \meet Cg(a,b) 
   * and \beta = Cg(a,c) \meet Cg(b,c) this gives number of alteration
   * of \alpha and \beta to get from a to c in the join of \alpha and
   * \beta. It returns -1 if (a,c) is not in the join.
   */
  public static int localDistributivityLevel(int a, int b, int c, 
                                             SmallAlgebra alg) {
    final Partition cgab = alg.con().Cg(a,b);
    final Partition cgac = alg.con().Cg(a,c);
    final Partition cgbc = alg.con().Cg(b,c);
    return BasicPartition.permutabilityLevel(a, c, 
                                       cgac.meet(cgab), cgac.meet(cgbc));
  }

  /**
   * Find the max level  over all triples a, b, c, where,
   * if \alpha = Cg(a,c) \meet Cg(a,b) 
   * and \beta = Cg(a,c) \meet Cg(b,c) the level is the number of alteration
   * of \alpha and \beta to get from a to c in the join of \alpha and
   * \beta. It return -1 if for some triple, (a,c) is not in the join.
   */
  public static int localDistributivityLevel(SmallAlgebra alg) {
    final int size = alg.cardinality();
    int maxLevel = -1;
    SmallAlgebra maxLevelAlg = null;
    for (int a = 0; a < size; a++) {
      for (int b = 0; b < size; b++) {
        for (int c = a + 1; c < size; c++) {  // a,c symmetry
          if (a == b || b == c) continue; // a == c is impossible
          BasicSet bs = alg.sub().sg(new int [] {a, b, c});
          Subalgebra sub = new Subalgebra(alg, bs);
          int level = localDistributivityLevel(sub.index(a), 
                                           sub.index(b), sub.index(c), sub);
          if (level == -1) return -1; // not distributive
          if (level > maxLevel) {
            maxLevel = level;
            maxLevelAlg = sub;
            //logger.info("max level now is " + maxLevel);
          }
        }
      }
    }
/*
System.out.println("the card of maxLevelAlg is " + maxLevelAlg.cardinality() +
                   ", its con size is " + maxLevelAlg.con().cardinality());
try {
org.uacalc.io.AlgebraIO.writeAlgebraFile(maxLevelAlg, "/tmp/baker4.xml");
}
catch (java.io.IOException e) {}
org.uacalc.ui.LatDrawer.drawLattice(new org.uacalc.lat.BasicLattice("", maxLevelAlg.con(), true));
*/
    return maxLevel;
  }


  /**
   * Find a weak majority term for (the variety generated by) this 
   * algebra or <tt>null</tt> if there is none. 
   * A <i>weak majority term</i> is one satifying
   * <tt>m(x,x,x) = x</tt> and <tt>m(x,x,y) = m(x,y,x) = m(y,x,x)</tt>.
   * Any finite algebra that has relational width 3 (in the sense 
   * of the constraint satisfaction problem) must have a 
   * weak-majority term. Questions (that Matt told me about):
   * <br>
   * 1. is there a finite algebra with Jonsson terms but no weak 
   * majority term?
   * <br>
   * 2. is there a finite algebra with a weak unamimity term but no 
   * weak majority term?
   * <br>
   * The method looks in the subalgebra generated by (x,x,y,x),
   * (x,y,x,x), (y,x,x,x) for an element of the form (a,a,a,x).
   */
  public static Term weakMajorityTerm(SmallAlgebra alg) {
    return weakMajorityTerm(alg, false);
  }

  /**
   * Find a weak majority term for (the variety generated by) this 
   * algebra or <tt>null</tt> if there is none using a faster algorithm
   * if the algebra is idempotent. 
   */
  public static Term weakMajorityTerm(SmallAlgebra alg, boolean isIdempotent) {
    if (alg.cardinality() == 1)  return Variable.x;
    FreeAlgebra f2 = new FreeAlgebra(alg, 2);
    // ** Need to put in a test if the tables will fit in memory. **
    f2.makeOperationTables();
    //logger.info("f2 size is " + f2.cardinality());
    IntArray g0;
    IntArray g1;
    IntArray g2;
    if (isIdempotent) {
      g0 = new IntArray(new int[] {0,0,1});
      g1 = new IntArray(new int[] {0,1,0});
      g2 = new IntArray(new int[] {1,0,0});
    }
    else {
      g0 = new IntArray(new int[] {0,0,1,0});
      g1 = new IntArray(new int[] {0,1,0,0});
      g2 = new IntArray(new int[] {1,0,0,0});
    }
    List gens = new ArrayList(3);
    gens.add(g0);
    gens.add(g1);
    gens.add(g2);
    final HashMap termMap = new HashMap(3);
    termMap.put(g0, Variable.x);
    termMap.put(g1, Variable.y);
    termMap.put(g2, Variable.z);
    //final IntArray yx = new IntArray(new int[] {1,0});
    BigProductAlgebra f2pow;
    if (isIdempotent) {
      f2pow = new BigProductAlgebra(f2, 3);
    }
    else {
      f2pow = new BigProductAlgebra(f2, 4);
    }
    // the yx argument means stop if yx is found. 
    // of course we want something different if we want the shortest term.
    List sub = f2pow.sgClose(gens, termMap);
    //logger.info("sub alg of the " + (isIdempotent ? "third" : "fourth")
    //   + " power of f2 size " + sub.size());
    //if (sub.contains(yx)) return (Term)termMap.get(yx);
    IntArray ia = null;
    for (Iterator it = sub.iterator(); it.hasNext(); ) {
      ia = (IntArray)it.next();
      if (ia.get(0) == ia.get(1) && ia.get(1) == ia.get(2)) {
        if (isIdempotent) break;
        if (ia.get(3) == 0) break; // last coord is x
      }
      ia = null;
    }
    if (ia != null) return (Term)termMap.get(ia);
    return null;
  }

  /**
   * This returns a list of Jonsson terms witnessing distributivity, or 
   * null if the algebra does generate a congruence distributive variety.
   * It is guaranteed to be the least number of terms possible.
   */
  public static List<Term> jonssonTerms(SmallAlgebra alg) {
    return jonssonTerms(alg, false);
  }
  
  public static List<Term> jonssonTerms(SmallAlgebra alg, boolean alvinVariant) {
    return jonssonTerms(alg, alvinVariant, null);
  }

  /**
   * This returns a list of Jonsson terms witnessing distributivity, or 
   * null if the algebra does generate a congruence distributive variety.
   * It is guaranteed to be the least number of terms possible.
   *
   * @param alvinVariant interchange even and odd in Jonsson's equations
   */
  public static List<Term> jonssonTerms(SmallAlgebra alg, 
                                        boolean alvinVariant, ProgressReport report) {
    if (report != null) report.addStartLine("finding Jonsson terms " 
    		                          + (alvinVariant ? " (ALV variant)" : ""));
    if (alg.isIdempotent()) {
      if (!isCongruenceDistIdempotent(alg, report)) {
        if (report != null) {
          report.addEndingLine("done finding Jonsson terms; there are none");
        }
        return null;
      }
    }
    List<Term> ans = new ArrayList<Term>();
    if (alg.cardinality() == 1) {
      ans.add(Variable.x);
      ans.add(Variable.z);
      return ans;
    }
    FreeAlgebra f2 = new FreeAlgebra(alg, 2, report);
    // ** Need to put in a test if the tables will fit in memory. **
    f2.makeOperationTables();
    //logger.info("f2 size is " + f2.cardinality());
    IntArray g0 = new IntArray(new int[] {0,0,1});
    IntArray g1 = new IntArray(new int[] {0,1,0});
    IntArray g2 = new IntArray(new int[] {1,0,0});
    List<IntArray> gens = new ArrayList<IntArray>(3);
    gens.add(g0);
    gens.add(g1);
    gens.add(g2);
    final HashMap<IntArray, Term> termMap = new HashMap<IntArray, Term>(3);
    termMap.put(g0, Variable.x);
    termMap.put(g1, Variable.y);
    termMap.put(g2, Variable.z);
    BigProductAlgebra f2cubed = new BigProductAlgebra(f2, 3);
    final IntArray zero = new IntArray(new int[] {0,0,0});
    final IntArray pixley = new IntArray(new int[] {1,0,1});
    //List sub;
    if (report != null)
      report.addStartLine("computing the subalgebra of F(2)^3 generated by (x,x,y) (x,y,x), (y,x,x).");
    List<IntArray> sub = f2cubed.sgClose(gens, termMap, null, report);
    if (report != null)
      report.addEndingLine("done finding subalgebra of F(2)^3.");
//System.out.println("sub = " + sub);
    if (report != null) report.addLine("sub alg of f2 cubed size is " + sub.size());
    if (sub.contains(pixley)) {
      if (report != null) report.addLine("this variety has a pixley term: " 
                                          + termMap.get(pixley));
    }
    else if (sub.contains(zero)) {
      if (report != null) report.addLine("this variety has a majority term");
    }
    if (alvinVariant) {
      if (sub.contains(pixley)) {
        //if (report != null) report.addLine("this variety has a pixley term");
        //logger.info("this variety has a pixley term");
        ans.add(Variable.x);
        ans.add(termMap.get(pixley));
        ans.add(Variable.z);
        return ans;
      }
    }
    else {
      if (sub.contains(zero)) {
        //if (report != null) report.addLine("this variety has a majority term");
        //logger.info("this variety has a ternary majority term");
        ans.add(Variable.x);
        ans.add(termMap.get(zero));
        ans.add(Variable.z);
        return ans;
      }
    }

    List<IntArray> middleZero = new ArrayList<IntArray>();
    for (Iterator<IntArray> it = sub.iterator(); it.hasNext(); ) {
      IntArray ia = it.next();
      if (ia.get(1) == 0) middleZero.add(ia);
    }
    Comparator<IntArray> c = new Comparator<IntArray>() {
        public int compare(IntArray ia1, IntArray ia2) {
          for (int i = 0; i < ia1.universeSize(); i++) {
            if (ia1.get(i) < ia2.get(i)) return -1;
            if (ia1.get(i) > ia2.get(i)) return 1;
          }
          return 0;
        }
        public boolean equals(Object o) { return false; }
    };
    Collections.sort(middleZero, c);
    //for (IntArray ia : middleZero) {  
    //  logger.finer("" + ia);
    //}
    final List path = jonssonLevelPath(middleZero, g0, g2, false);
    final List path2 = jonssonLevelPath(middleZero, g0, g2, true);
    if (path == null) {
      if (path2 == null) return null;
      ans = path2TermList(path2, termMap);
      if (!alvinVariant) {
        ans.add(0, ans.get(0));
        if (report != null) report.addLine("The ALVIN variant is shorter than Jonsson.");
        // add to info that the alv variant Jon terms are shorter
      }
      return ans;
    }
    if (path2 == null || path.size() < path2.size()) {
      ans = path2TermList(path, termMap);
      if (alvinVariant) {
        ans.add(0, ans.get(0));
        if (report != null) report.addLine("Jonsson is shorter than the ALVIN variant.");
        // add to info that the Jon is shorter than alv variant 
      }
      return ans;
    }
    if (alvinVariant) return path2TermList(path2, termMap);
    if (path2.size() < path.size()) {
      ans = path2TermList(path2, termMap);
      ans.add(0, ans.get(0));
      return ans;
    }
    return path2TermList(path, termMap);
  }
  
  /**
   * The polynomial time test if the idempotent algebra <code>alg</code> 
   * generates a CD variety from Freese-Valeriote. It first tests if 
   * there is a Day quadrangle then if there is a failure of SD-meet. 
   * 
   * @param alg
   * @param report
   * @return
   */
  public static boolean isCongruenceDistIdempotent(SmallAlgebra alg, ProgressReport report) {
    if (report != null) {
      report.addStartLine("Testing if V(A) is CD");
      report.addLine("First look for a Day quadruple, then check if V(A) is con SD-meet.");
    }
    if (findDayQuadrupleInSquare(alg, report) != null  || 
        sdMeetIdempotent(alg, report) != null) {
      if (report != null) report.addEndingLine("V(A) is not CD.");
      return false;        
    }
    if (report != null) report.addEndingLine("V(A) is CD.");
    return true;
  }
  
  public static boolean isCongruenceModularIdempotent(SmallAlgebra alg, ProgressReport report) {
    if (report != null) report.addStartLine("Testing if V(A) is CM");
    if (findDayQuadrupleInSquare(alg, report) != null) {
      if (report != null) report.addEndingLine("V(A) is not CM.");
      return false;        
    }
    if (report != null) report.addEndingLine("V(A) is CM.");
    return true;
  }

  public static List<Term> sdTerms(SmallAlgebra alg, ProgressReport report) {
    if (report != null) report.addStartLine("Finding Semidistributive terms ");
    if (alg.isIdempotent()) {
      if (sdIdempotent(alg, report) != null) {
        if (report != null) report.addEndingLine("There are none. ");
        return null;
      }
      else {
        if (report != null) report.addLine("The variety is congruence semidistributive; looking for terms. ");
      }
      // put in idempotent test for omitting 1, 2, 5
      
      //if (findDayQuadrupleInSquare(alg, report) != null) {
      //  if (report != null) {
      //    report.addEndingLine("done finding Jonsson terms; there are none");
      //  }
      //  return null;
      //}
    }
    List<Term> ans = new ArrayList<Term>();
    if (alg.cardinality() == 1) {
      ans.add(Variable.x);
      ans.add(Variable.z);
      return ans;
    }
    FreeAlgebra f2 = new FreeAlgebra(alg, 2, report);
    // ** Need to put in a test if the tables will fit in memory. **
    f2.makeOperationTables();
    //logger.info("f2 size is " + f2.cardinality());
    IntArray g0 = new IntArray(new int[] {0,0,1});
    IntArray g1 = new IntArray(new int[] {0,1,0});
    IntArray g2 = new IntArray(new int[] {1,0,0});
    List<IntArray> gens = new ArrayList<IntArray>(3);
    gens.add(g0);
    gens.add(g1);
    gens.add(g2);
    final HashMap<IntArray, Term> termMap = new HashMap<IntArray, Term>(3);
    termMap.put(g0, Variable.x);
    termMap.put(g1, Variable.y);
    termMap.put(g2, Variable.z);
    BigProductAlgebra f2cubed = new BigProductAlgebra(f2, 3);
    final IntArray zero = new IntArray(new int[] {0,0,0}); // majority term
    final IntArray pixley = new IntArray(new int[] {1,0,1});
    
    if (report != null)
      report.addStartLine("computing the subalgebra of F(2)^3 generated by (x,x,y) (x,y,x), (y,x,x).");
    List<IntArray> sub = f2cubed.sgClose(gens, termMap, null, report);
    if (report != null)
      report.addEndingLine("done finding subalgebra of F(2)^3.");
    //System.out.println("sub = " + sub);
    if (report != null) report.addLine("sub alg of f2 cubed size is " + sub.size());
    if (sub.contains(pixley)) {
      if (report != null) report.addLine("this variety has a pixley term: " 
          + termMap.get(pixley));
    }
    else if (sub.contains(zero)) {
      if (report != null) report.addLine("this variety has a majority term");
    }
    
    if (sub.contains(zero)) {
      //if (report != null) report.addLine("this variety has a majority term");
      //logger.info("this variety has a ternary majority term");
      ans.add(Variable.x);
      ans.add(termMap.get(zero));
      ans.add(Variable.z);
      return ans;
    }
    
    List<IntArray> middleZero = new ArrayList<IntArray>();
    for (Iterator<IntArray> it = sub.iterator(); it.hasNext(); ) {
      IntArray ia = it.next();
      if (ia.get(1) == 0) middleZero.add(ia);
    }
    Comparator<IntArray> c = new Comparator<IntArray>() {
      public int compare(IntArray ia1, IntArray ia2) {
        for (int i = 0; i < ia1.universeSize(); i++) {
          if (ia1.get(i) < ia2.get(i)) return -1;
          if (ia1.get(i) > ia2.get(i)) return 1;
        }
        return 0;
      }
      public boolean equals(Object o) { return false; }
    };
    Collections.sort(middleZero, c);
    
    boolean alvinVariant = false;
    
    final List<IntArray> path = jonssonLevelPath(middleZero, g0, g2, false);
    final List<IntArray> path2 = jonssonLevelPath(middleZero, g0, g2, true);
    if (path != null || path2 != null) {
      if (path == null) {
        ans = path2TermList(path2, termMap);
        if (!alvinVariant) {
          ans.add(0, ans.get(0));
          if (report != null) report.addLine("This is CD and the ALVIN variant is shorter than Jonsson.");
          // add to info that the alv variant Jon terms are shorter
        }
        return ans;
      }
      if (path2 == null || path.size() < path2.size()) {
        ans = path2TermList(path, termMap);
        if (alvinVariant) {
          ans.add(0, ans.get(0));
          if (report != null) report.addLine("This generates a CD variety and Jonsson terms are shorter than the ALVIN variant.");
          // add to info that the Jon is shorter than alv variant 
        }
        return ans;
      }
      if (alvinVariant) return path2TermList(path2, termMap);
      if (path2.size() < path.size()) {
        ans = path2TermList(path2, termMap);
        ans.add(0, ans.get(0));
        if (report != null) report.addLine("This generates a CD variety.");
        return ans;
      }
      if (report != null) report.addLine("This generates a CD variety.");
      return path2TermList(path, termMap);
    }
    // the real SD code here:
    if (report != null) {
      report.addLine("This variety is not congruence distributive.");
      report.addLine("Checking if this variety is congruencre SD-meet.");
    }
    Collections.sort(sub, IntArray.lexicographicComparitor());
    final List<IntArray> path3 = sdPath(sub, g0, g2);
    if (path3 != null) {
      if (report != null) report.addLine("This variety is congruence semidistributive.");
      return path2TermList(path3, termMap);
    }
    return null;
  }

  /**
   * This uses Theorem 4.2 of Freese-Valeriote to test if the 
   * algebra omits type 1, 2 and 5; that is, is congruence SD. 
   * It returns the x and y witnessing the failure or null if
   * there is no failure.
   * 
   * @param alg  the algebra, assumed to be idempotent
   * @param report
   * @return x and y in alg that witness the failure or null if there is none
   */
  public static IntArray sdIdempotent(SmallAlgebra alg, ProgressReport report) {
    if (report != null) {
      report.addStartLine("Using Thm 4.2 of Freese-Valeriote to test if V(A) is SD-join");
    }
    final int n = alg.cardinality();
    final BigProductAlgebra sq = new BigProductAlgebra(alg, 2);
    final IntArray a = new IntArray(2);
    final IntArray b = new IntArray(2);
    final IntArray c = new IntArray(2);
    final List<IntArray> gens = new ArrayList<IntArray>(3);
    gens.add(a);
    gens.add(b);
    gens.add(c);
    for (int x = 0; x < n; x++) {
      for (int y = 0; y < n; y++) {
        if (x == y) continue;
        a.set(0, x);
        a.set(1, x);
        b.set(0, x);
        b.set(1, y);
        c.set(0, y);
        c.set(1, x);
        final SmallAlgebra sub = new SubProductAlgebra("", sq, gens);
        final int aIndex = sub.elementIndex(a);
        final int bIndex = sub.elementIndex(b);
        final int cIndex = sub.elementIndex(c);
        Partition alpha = sub.con().Cg(aIndex, cIndex);
        Partition beta = sub.con().Cg(aIndex, bIndex);
        Partition gamma = sub.con().Cg(bIndex, cIndex);
        if (!alpha.meet(beta).join(gamma).isRelated(aIndex, cIndex)) {
          if (report != null) {
            report.setWitnessAlgebra(new AlgebraWithGeneratingVector(sub, 
                new int[] {aIndex, bIndex, cIndex}));
            report.addLine("Found a failure of Theorem 4.2 of Freese-Valeriote");
            report.addLine("with x = " + x + ", y = " + y);
            report.addLine("This algebra admits either type 1, 2 or 5.");
            report.addEndingLine("So this algebra does not generate an SD variety"); 
          }
          return new IntArray(new int[] {x, y});
        }
      }
    }
    if (report != null) {
      report.addEndingLine("V(A) is congruence semidistributive.");
    }
    return null;
  }
    
  
  private static List<Term> path2TermList(List<IntArray> path, 
                                          HashMap<IntArray, Term> termMap) {
    List<Term> ans = new ArrayList<Term>();
    for (IntArray ia : path) {
      ans.add(termMap.get(ia));
    }
    return ans;
  }
  
  /**
   * This finds a path from g0 to g2 in <tt>middleZero</tt>, a list
   * of triples, where two triples are connected by an edge if either
   * their first or third coordinates agree. When alvinVariant is 
   * true, it starts with changing the third coordinate; otherwise
   * with the first.
   */
  public static List<IntArray> sdPath(List<IntArray> subalg, 
      IntArray g0, IntArray g2) {
    // We need to allow for the possibility that we can't
    // get started, especially for the alvinVariant.
    // I suspect, but haven't been able prove, that if 
    // terms exist in the alvinVariant, they exist (and
    // with the same number) in the original Jonsson condition.
    // It is easy when the "level" odd (each implies the other)
    // and it is also true when the level is 2 (a pixley term
    // implies a majority term).
    //
    // Actually this (alvin CD => CD) is false; as is shown in the paper with Matt.

    // TODO: write the code for this.
    final List<List<IntArray>> levels = new ArrayList<List<IntArray>>();
    final Map<IntArray,IntArray> parentMap = new HashMap<IntArray,IntArray>();
    List<IntArray> currentLevel = new ArrayList<IntArray>();
    //final HashSet visited = new HashSet();
    currentLevel.add(g0);
    parentMap.put(g0, null);
    levels.add(currentLevel);
    HashMap<IntArray,List<IntArray>> classes01 = new HashMap<IntArray,List<IntArray>>();
    //HashMap<Integer,List<IntArray>> classes1 = new HashMap<Integer,List<IntArray>>();
    HashMap<Integer,List<IntArray>> classes2 = new HashMap<Integer,List<IntArray>>();
    for (Iterator<IntArray> it = subalg.iterator(); it.hasNext(); ) {
      IntArray ia = it.next();
      IntArray ia_01 = new IntArray(new int[] {ia.get(0), ia.get(1)});
      //Integer ia_0 = new Integer(ia.get(0));
      //Integer ia_1 = new Integer(ia.get(1));
      Integer ia_2 = new Integer(ia.get(2));
      List<IntArray> eqclass = classes01.get(ia_01);
      if (eqclass == null) {
        eqclass = new ArrayList<IntArray>();
        classes01.put(ia_01, eqclass);
      }
      eqclass.add(ia);
      
      eqclass = classes2.get(ia_2);
      if (eqclass == null) {
        eqclass = new ArrayList<IntArray>();
        classes2.put(ia_2, eqclass);
      }
      eqclass.add(ia);
    } 
    boolean even = false;
    boolean first = true;
    while (true) {
      even = !even;
      final List<IntArray> nextLevel = new ArrayList<IntArray>();
      //System.out.println("current level size = " + currentLevel.size());
      //System.out.println("even = " + even);
      //System.out.println("current level size = " + currentLevel.size());
      for (IntArray ia : currentLevel) {
        List<IntArray> eqclass;
        if (even) eqclass = classes01.get(new IntArray(new int[] {ia.get(0), ia.get(1)}));
        else eqclass = classes2.get(ia.get(2));
        //eqclass.remove(ia);
        for (IntArray ia2 : eqclass) {
          //if (ia2.equals(ia)) continue;
          if (!parentMap.containsKey(ia2)) {
            parentMap.put(ia2, ia);
            nextLevel.add(ia2);
          }
          if (ia2.equals(g2)) {
            final List<IntArray> path = new ArrayList<IntArray>(levels.size() + 1);
            path.add(g2);
            ia2 = parentMap.get(ia2);
            while (ia2 != null) {
              path.add(ia2);
              ia2 = parentMap.get(ia2);
            }
            Collections.reverse(path);
            for (Iterator<IntArray> iter = path.iterator(); iter.hasNext(); ) {
              System.out.println("" + iter.next());
            }
            return path;
          }
        }
      }
      if (nextLevel.isEmpty()) {
        if (!first) break;
        else {
          first = false;
          continue;
        }
      }
      first = false;
      levels.add(nextLevel);
      currentLevel = nextLevel;
    }
    return null;
  }


  
  /**
   * This finds a path from g0 to g2 in <tt>middleZero</tt>, a list
   * of triples, where two triples are connected by an edge if either
   * their first or third coordinates agree. When alvinVariant is 
   * true, it starts with changing the third coordinate; otherwise
   * with the first.
   */
  public static List<IntArray> jonssonLevelPath(List<IntArray> middleZero, 
                                      IntArray g0, IntArray g2,
                                      boolean alvinVariant) {
    // We need to allow for the possibility that we can't
    // get started, especially for the alvinVariant.
    // I suspect, but haven't been able prove, that if 
    // terms exist in the alvinVariant, they exist (and
    // with the same number) in the original Jonsson condition.
    // It is easy when the "level" odd (each implies the other)
    // and it is also true when the level is 2 (a pixley term
    // implies a majority term).
    //
    // Actually this (alvin CD => CD) is false; as is shown in the paper with Matt.

    final List<List<IntArray>> levels = new ArrayList<List<IntArray>>();
    final Map<IntArray,IntArray> parentMap = new HashMap<IntArray,IntArray>();
    List<IntArray> currentLevel = new ArrayList<IntArray>();
    //final HashSet visited = new HashSet();
    currentLevel.add(g0);
    parentMap.put(g0, null);
    levels.add(currentLevel);
    /*
    Comparator<IntArray> c0 = new Comparator<IntArray>() {
        public int compare(IntArray o1, IntArray o2) {
          return o2.get(0) - o1.get(0);
        }
    };
    Comparator<IntArray> c2 = new Comparator<IntArray>() {
        public int compare(IntArray o1, IntArray o2) {
          return o2.get(2) - o1.get(2);
        }
    };
    */
    HashMap<Integer,List<IntArray>> classes0 = new HashMap<Integer,List<IntArray>>();
    HashMap<Integer,List<IntArray>> classes2 = new HashMap<Integer,List<IntArray>>();
    for (Iterator<IntArray> it = middleZero.iterator(); it.hasNext(); ) {
      IntArray ia = it.next();
      Integer ia_0 = new Integer(ia.get(0));
      Integer ia_2 = new Integer(ia.get(2));
      List<IntArray> eqclass = classes0.get(ia_0);
      if (eqclass == null) {
        eqclass = new ArrayList<IntArray>();
        classes0.put(ia_0, eqclass);
      }
      eqclass.add(ia);
      eqclass = classes2.get(ia_2);
      if (eqclass == null) {
        eqclass = new ArrayList<IntArray>();
        classes2.put(ia_2, eqclass);
      }
      eqclass.add(ia);
    } 
    boolean even = alvinVariant;
    while (true) {
      even = !even;
      final List<IntArray> nextLevel = new ArrayList<IntArray>();
//System.out.println("current level size = " + currentLevel.size());
      //System.out.println("even = " + even);
      //System.out.println("current level size = " + currentLevel.size());
      for (Iterator<IntArray> it = currentLevel.iterator(); it.hasNext(); ) {
        IntArray ia = it.next();
        List<IntArray> eqclass;
        if (even) eqclass = classes0.get(ia.get(0));
        else eqclass = classes2.get(ia.get(2));
        //eqclass.remove(ia);
        for (Iterator<IntArray> it2 = eqclass.iterator(); it2.hasNext(); ) {
          IntArray ia2 = it2.next();
          //if (ia2.equals(ia)) continue;
          if (!parentMap.containsKey(ia2)) {
            parentMap.put(ia2, ia);
            nextLevel.add(ia2);
          }
          if (ia2.equals(g2)) {
            final List<IntArray> path = new ArrayList<IntArray>(levels.size() + 1);
            path.add(g2);
            ia2 = parentMap.get(ia2);
            while (ia2 != null) {
              path.add(ia2);
              ia2 = parentMap.get(ia2);
            }
            Collections.reverse(path);
            return path;
          }
        }
      }
      if (nextLevel.isEmpty()) break;    
      levels.add(nextLevel);
      currentLevel = nextLevel;
    }
    return null;
  }

  /**
   * If this algebra generates a distributive variety, this returns
   * the minimal number of Jonsson terms minus 1; otherwise it returns -1,
   * but it is probably better to use <tt>jonssonTerms</tt> and get
   * get the actual terms.
   * So congruence distributivity can be tested by seeing if this 
   * this is positive. If the algebra has only one element, it returns 1.
   * For a lattice it returns 2. For Miklos Marioti's 5-ary near unanimity
   * operation on a 4 element set, it returns 6 (the maximum possible).
   */
  public static int jonssonLevel(SmallAlgebra alg) {
    if (alg.cardinality() == 1) return 1;
    FreeAlgebra f2 = new FreeAlgebra(alg, 2);
    f2.makeOperationTables();
    //logger.info("f2 size is " + f2.cardinality());
    IntArray g0 = new IntArray(new int[] {0,0,1});
    IntArray g1 = new IntArray(new int[] {0,1,0});
    IntArray g2 = new IntArray(new int[] {1,0,0});
    List<IntArray> gens = new ArrayList<IntArray>(3);
    gens.add(g0);
    gens.add(g1);
    gens.add(g2);
    final HashMap<IntArray,Term> termMap = new HashMap<IntArray,Term>(3);
    termMap.put(g0, Variable.x);
    termMap.put(g1, Variable.y);
    termMap.put(g2, Variable.z);
    BigProductAlgebra f2cubed = new BigProductAlgebra(f2, 3);
    List<IntArray> sub = f2cubed.sgClose(gens, termMap);
    //logger.info("sub alg of f2 cubed size is " + sub.size());
    final IntArray zero = new IntArray(new int[] {0,0,0});
    if (sub.contains(zero)) {
      //logger.info("this variety has a ternary majority function");
      return 2;
    }
    List<IntArray> middleZero = new ArrayList<IntArray>();
    for (IntArray ia : sub) {
      if (ia.get(1) == 0) middleZero.add(ia);
    }
    Comparator<IntArray> c = new Comparator<IntArray>() {
        public int compare(IntArray ia1, IntArray ia2) {
          for (int i = 0; i < ia1.universeSize(); i++) {
            if (ia1.get(i) < ia2.get(i)) return -1;
            if (ia1.get(i) > ia2.get(i)) return 1;
          }
          return 0;
        }
        public boolean equals(Object o) { return false; }
    };
    Collections.sort(middleZero, c);
    return jonssonLevelAux(middleZero, g0, g2);
  }

  public static int jonssonLevelAux(List<IntArray> middleZero, IntArray g0,
                                              IntArray g2) {
    // a list of lists of IntArray's
    final List levels = new ArrayList();
    List currentLevel = new ArrayList();
    final HashSet visited = new HashSet();
    currentLevel.add(new IntArray[] {g0, null});
    visited.add(g0);
    levels.add(currentLevel);
    Comparator c0 = new Comparator() {
        public int compare(Object o1, Object o2) {
          return ((IntArray)o2).get(0) - ((IntArray)o1).get(0);
        }
    };
    Comparator c2 = new Comparator() {
        public int compare(Object o1, Object o2) {
          return ((IntArray)o2).get(2) - ((IntArray)o1).get(2);
        }
    };
    HashMap classes0 = new HashMap();
    HashMap classes2 = new HashMap();
    for (Iterator it = middleZero.iterator(); it.hasNext(); ) {
      IntArray ia = (IntArray)it.next();
      Integer ia_0 = new Integer(ia.get(0));
      Integer ia_2 = new Integer(ia.get(2));
      List eqclass = (List)classes0.get(ia_0);
      if (eqclass == null) {
        eqclass = new ArrayList();
        classes0.put(ia_0, eqclass);
      }
      eqclass.add(ia);
      eqclass = (List)classes2.get(ia_2);
      if (eqclass == null) {
        eqclass = new ArrayList();
        classes2.put(ia_2, eqclass);
      }
      eqclass.add(ia);
    } 
    boolean even = false;
    while (true) {
      if (even) even = false;
      else even = true;
      final List nextLevel = new ArrayList();
//System.out.println("current level size = " + currentLevel.size());
      for (Iterator it = currentLevel.iterator(); it.hasNext(); ) {
        IntArray ia = ((IntArray[])it.next())[0];
        List eqclass;
        if (even) eqclass = (List)classes0.get(new Integer(ia.get(0)));
        else eqclass = (List)classes2.get(new Integer(ia.get(2)));
        //eqclass.remove(ia);
        for (Iterator it2 = eqclass.iterator(); it2.hasNext(); ) {
          IntArray ia2 = (IntArray)it2.next();
          //if (ia2.equals(ia)) continue;
          if (ia2.equals(g2)) {
//System.out.println("returning " + (levels.size() + 1));

            return levels.size();
          }
          if (!visited.contains(ia2)) {
            visited.add(ia2);
            nextLevel.add(new IntArray[] {ia2, ia});
          }
        }
      }
      if (nextLevel.isEmpty()) break;    
      levels.add(nextLevel);
      currentLevel = nextLevel;
//System.out.println("levels size is " + levels.size());
    }
    return -1;
  }

  /**
   * Find a Day quadruple of the form a = (x0, x1), b = (x0, y1),
   * c = y0, x1), d = (y0, y1). Since Day quadruples are invariant
   * under the permutation (ab)(cd), we can take x1 &lt; y1.
   *
   */
  public static IntArray findDayQuadrupleInSquare(final SmallAlgebra alg,
                                                  final ProgressReport report) {
    if (report != null) report.addStartLine("Looking for a Day quadruple in A^2");
    final int n = alg.cardinality();
    final BigProductAlgebra sq = new BigProductAlgebra(alg, 2);
    final IntArray a = new IntArray(2);
    final IntArray b = new IntArray(2);
    final IntArray c = new IntArray(2);
    final IntArray d = new IntArray(2);
    final int[] avec = a.toArray();
    final int[] bvec = b.toArray();
    final int[] cvec = c.toArray();
    final int[] dvec = d.toArray();
    final List<IntArray> gens = new ArrayList<IntArray>(4);
    gens.add(a);
    gens.add(b);
    gens.add(c);
    gens.add(d);
    for (int x0 = 0; x0 < n; x0++) {
      for (int x1 = 0; x1 < n; x1++) {
        for (int y0 = 0; y0 < n; y0++) {
          for (int y1 = x1 + 1; y1 < n; y1++) {
            avec[0] = x0;
            avec[1] = x1;
            bvec[0] = x0;
            bvec[1] = y1;
            cvec[0] = y0;
            cvec[1] = x1;
            dvec[0] = y0;
            dvec[1] = y1;
//System.out.println("x0 = " + x0 + ", x1 = " + x1 + 
//                  ", y0 = " + y0 + ", y1 = " + y1);
            final SmallAlgebra sub = new SubProductAlgebra("", sq, gens);
//TypeFinder tf = new TypeFinder(sub);
//System.out.println("types = " + tf.findTypeSet());

            final int aIndex = sub.elementIndex(a);
            final int bIndex = sub.elementIndex(b);
            final int cIndex = sub.elementIndex(c);
            final int dIndex = sub.elementIndex(d);
            
            if (dayQuadruple(aIndex, bIndex, cIndex, dIndex, sub)) {
              if (report != null) {
                report.setWitnessAlgebra(new AlgebraWithGeneratingVector(sub, 
                                         new int[] {aIndex, bIndex, cIndex, dIndex}));
                report.addLine("Found a Day quadruple in the subalgebra of A^2");
                report.addLine("generated by a = (" + x0 + "," + x1 + "), b = ("
                               + x0 + "," + y1 + "), c = ("
                               + y0 + "," + x1 + "), d = ("
                               + y0 + "," + y1 + ")");
                report.addEndingLine("the congruences Cg(c,d), Cg(a,b)(c,d) and Cg(a,c)(b,d) generate " 
                               + " a nonmodular lattice");
              }
              return new IntArray(new int[] {x0, x1, y0, y1});
            }
          }
        }
      }
    }
    if (report != null) {
      report.addLine("There is no Day quadruple in the subalgebras of A^2.");
      report.addEndingLine("So this algebra lies in a CM variety.");
    }
    return null;
  }


  /**
   * Check if a, b, c, d form a Day Quadruple in alg.
   * 
   * @param a
   * @param b
   * @param c
   * @param d
   * @param alg
   * @return
   */
  public static boolean dayQuadruple(int a, int b, int c, int d,
                                                     SmallAlgebra alg) {
    final Partition cgcd = alg.con().Cg(c,d);
    final Partition cgab_cd = alg.con().Cg(a,b).join(cgcd);
    final Partition cgac_bd = alg.con().Cg(a,c).join(alg.con().Cg(b, d));
    return !cgcd.join(cgab_cd.meet(cgac_bd)).isRelated(a,b);
  }

  /**
   * Test if alg generates a CM variety by looking for
   * a Day quadruple in the square of the free algebra
   * on 2 generators. Use the faster method if alg is idempotent.
   * 
   * @param alg
   * @param report
   * @return
   */
  public static boolean congruenceModularVariety(SmallAlgebra alg) {
    return congruenceModularVariety(alg, null);
  }
  
  /**
   * Test if alg generates a CM variety by looking for
   * a Day quadruple in the square of the free algebra
   * on 2 generators. Use the faster method if alg is idempotent.
   * 
   * @param alg
   * @param report
   * @return
   */
  public static boolean congruenceModularVariety(SmallAlgebra alg, ProgressReport report) {
    if (alg.isIdempotent()) return congruenceModularForIdempotent(alg, report);
    FreeAlgebra f2 = new FreeAlgebra(alg, 2);
    // ** Need to put in a test if the tables will fit in memory. **
    f2.makeOperationTables();
    //List gens = f2.generators();
    IntArray a = new IntArray(new int[] {0,0});
    IntArray b = new IntArray(new int[] {0,1});
    IntArray c = new IntArray(new int[] {1,0});
    IntArray d = new IntArray(new int[] {1,1});
    List<IntArray> gens = new ArrayList<IntArray>(4);
    gens.add(a);
    gens.add(b);
    gens.add(c);
    gens.add(d);
    BigProductAlgebra f2squared = new BigProductAlgebra(f2, 2);
    //List sub = f2squared.sgClose(gens, termMap);
    SmallAlgebra sub = new SubProductAlgebra("", f2squared, gens);
    // ** Need to put in a test if the tables will fit in memory. **
    sub.makeOperationTables();
    Partition cgcd = sub.con().Cg(c, d);
    return cgcd.isRelated(sub.elementIndex(a), sub.elementIndex(b));
  }

  /**
   * Use the polynomial type algorithm from Freese-Valeriote to 
   * test if <code>alg</code> generates a CM variety. This seaches 
   * for a Day quadruple in the square of <code>alg</code>.
   * 
   * @param alg
   * @param report
   * @return
   */
  public static boolean congruenceModularForIdempotent(SmallAlgebra alg, ProgressReport report) {
    if (findDayQuadrupleInSquare(alg, null) != null) return false;
    return true;
  }


  /**
   * This returns a list of Gumm terms witnessing modularity, or null if 
   * the algebra does generate a congruence modular variety.
   * It is guarenteed to be the least number of terms possible.
   */
  public static List<Term> gummTerms(SmallAlgebra alg) {
    return gummTerms(alg, null);
  }
  
  /**
   * This returns a list of Gumm terms witnessing modularity, or null if 
   * the algebra does generate a congruence modular variety.
   * It is guarenteed to be the least number of terms possible.
   */
  public static List<Term> gummTerms(SmallAlgebra alg,  ProgressReport report) {
    return gummTerms(alg, null, report);
  }
  
  /**
   * This returns a list of Gumm terms witnessing modularity, or null if 
   * the algebra does generate a congruence modular variety.
   * It is guarenteed to be the least number of terms possible.
   */
  public static List<Term> gummTerms(SmallAlgebra alg, FreeAlgebra free2, ProgressReport report) { 
    if (report != null) report.addStartLine("Finding Gumm terms.");
    if (alg.isIdempotent()) {
      if (findDayQuadrupleInSquare(alg, report) != null) {
        if (report != null) {
          report.addEndingLine("done finding Gumm terms; there are none");
        }
        return null;
      }
    }
    List<Term> ans = new ArrayList<Term>();
    if (alg.cardinality() == 1) {
      ans.add(Variable.x);
      ans.add(Variable.z);
      return ans;
    }
    FreeAlgebra f2 = free2;
    if (f2 == null) f2 = new FreeAlgebra(alg, 2, report);
    // ** If the tables don't fit in memory, this just doesn't do anything. **
    f2.makeOperationTables();
    //logger.info("f2 size is " + f2.cardinality());
    IntArray g0 = new IntArray(new int[] {0,0,1});
    IntArray g1 = new IntArray(new int[] {0,1,0});
    IntArray g2 = new IntArray(new int[] {1,0,0});
    List<IntArray> gens = new ArrayList<IntArray>(3);
    gens.add(g0);
    gens.add(g1);
    gens.add(g2);
    final HashMap<IntArray,Term> termMap = new HashMap<IntArray,Term>(3);
    termMap.put(g0, Variable.x);
    termMap.put(g1, Variable.y);
    termMap.put(g2, Variable.z);
    BigProductAlgebra f2cubed = new BigProductAlgebra(f2, 3);
    
    report.addStartLine("computing the subalgebra of F(2)^3 generated by (x,x,y) (x,y,x), (y,x,x).");
    List<IntArray> sub = f2cubed.sgClose(gens, termMap, null, report);
    report.addEndingLine("done finding subalgebra of F(2)^3.");
    
    
    //logger.info("sub alg of f2 cubed size is " + sub.size());
    final IntArray zero = new IntArray(new int[] {0,0,0});
    if (sub.contains(zero)) {
      //logger.info("this variety has a ternary majority function");
      if (report != null) report.addLine("this variety has a majority term: " + termMap.get(zero));
      ans.add(Variable.x);
      ans.add(termMap.get(zero));
      ans.add(Variable.z);
      return ans;
    }
    List<IntArray> middleZero = new ArrayList<IntArray>();
    for (IntArray ia : sub) {
      if (ia.get(1) == 0) middleZero.add(ia);
    }
    List<IntArray> firstOne = new ArrayList<IntArray>();
    for (IntArray ia : sub) {
      if (ia.get(0) == 1) firstOne.add(ia);
    }
    final Comparator<IntArray> c = new Comparator<IntArray>() {
        public int compare(IntArray ia1, IntArray ia2) {
          for (int i = 0; i < ia1.universeSize(); i++) {
            if (ia1.get(i) < ia2.get(i)) return -1;
            if (ia1.get(i) > ia2.get(i)) return 1;
          }
          return 0;
        }
        public boolean equals(Object o) { return false; }
    };
    Collections.sort(middleZero, c);
    //Collections.sort(firstOne, c);
    //for (Iterator it = middleZero.iterator(); it.hasNext(); ) {
    //  logger.finer("" + it.next());
    //}
    final List<IntArray> path = gummLevelPath(middleZero, firstOne, g0, g2);
    if (path == null) {
      if (report != null) report.addEndingLine("this variety is not congruence modular");
      return null;
    }
    for (IntArray ia : path) {
      ans.add(termMap.get(ia));
    }
    if (report != null) report.addEndingLine("done finding Gumm terms.");
    return ans;
  }

  /**
   * Change this a little:
   * This finds a path from g0 to u, then v. The path from g0 to u is 
   * in <tt>middleZero</tt>, and u and v agree on the third coordinate
   * and v has 1 (the second free generator of F_2) in its first 
   * coordinate. The path from g0 to u is a a list
   * of triples, where two triples are connected by an edge if either
   * their first or third coordinates agree.
   */
  public static List<IntArray> gummLevelPath(List<IntArray> middleZero, List<IntArray> firstOne, 
                                             IntArray g0, IntArray g2) {
    // a list of lists of IntArray's
    final List levels = new ArrayList();
    final Map parentMap = new HashMap();
    List currentLevel = new ArrayList();
    //final HashSet visited = new HashSet();
    currentLevel.add(g0);
    parentMap.put(g0, null);
    levels.add(currentLevel);
    Comparator c0 = new Comparator() {
        public int compare(Object o1, Object o2) {
          return ((IntArray)o2).get(0) - ((IntArray)o1).get(0);
        }
    };
    Comparator c2 = new Comparator() {
        public int compare(Object o1, Object o2) {
          return ((IntArray)o2).get(2) - ((IntArray)o1).get(2);
        }
    };
    HashMap classes0 = new HashMap();
    HashMap classes2 = new HashMap();
    for (Iterator it = middleZero.iterator(); it.hasNext(); ) {
      IntArray ia = (IntArray)it.next();
      Integer ia_0 = new Integer(ia.get(0));
      Integer ia_2 = new Integer(ia.get(2));
      List eqclass = (List)classes0.get(ia_0);
      if (eqclass == null) {
        eqclass = new ArrayList();
        classes0.put(ia_0, eqclass);
      }
      eqclass.add(ia);
      eqclass = (List)classes2.get(ia_2);
      if (eqclass == null) {
        eqclass = new ArrayList();
        classes2.put(ia_2, eqclass);
      }
      eqclass.add(ia);
    }
    // classes1 is for the firstOne
    HashMap classes1 = new HashMap();
    for (Iterator it = firstOne.iterator(); it.hasNext(); ) {
      IntArray ia = (IntArray)it.next();
      Integer ia_2 = new Integer(ia.get(2));
      List eqclass = (List)classes1.get(ia_2);
      if (eqclass == null) {
        eqclass = new ArrayList();
        classes1.put(ia_2, eqclass);
      }
      eqclass.add(ia);
    }
    boolean even = false;
    while (true) {
      even = !even;
      final List nextLevel = new ArrayList();
//System.out.println("current level size = " + currentLevel.size());
      for (Iterator it = currentLevel.iterator(); it.hasNext(); ) {
        IntArray ia = (IntArray)it.next();
        List eqclass;
        if (even) eqclass = (List)classes0.get(new Integer(ia.get(0)));
        else eqclass = (List)classes2.get(new Integer(ia.get(2)));
        //eqclass.remove(ia);
        for (Iterator it2 = eqclass.iterator(); it2.hasNext(); ) {
          IntArray ia2 = (IntArray)it2.next();
          //if (ia2.equals(ia)) continue;
          if (!parentMap.containsKey(ia2)) {
            parentMap.put(ia2, ia);
            nextLevel.add(ia2);
          }
          // here
          eqclass = (List)classes1.get(new Integer(ia2.get(2)));
          if (eqclass != null) {
            IntArray p = (IntArray)eqclass.get(0);
            if (eqclass.contains(g2)) p = g2;
            final List path = new ArrayList(levels.size() + 1);
            if (!eqclass.contains(ia2)) path.add(p);
            path.add(ia2);
            ia2 = (IntArray)parentMap.get(ia2);
            while (ia2 != null) {
              path.add(ia2);
              ia2 = (IntArray)parentMap.get(ia2);
            }
            Collections.reverse(path);
            //logger.fine("path");
            //for (Iterator iter = path.iterator(); iter.hasNext(); ) {
            //  logger.fine("" + iter.next());
            //}
            return path;
          }
        }
      }
      if (nextLevel.isEmpty()) break;    
      levels.add(nextLevel);
      currentLevel = nextLevel;
    }
    return null;
  }

  /**
   * This uses Theorem 5.1 of Freese-Valeriote to test if the 
   * algebra the algebra generates a CP variety.
   * It returns the x0, x1, y0 and y1 witnessing the failure or null if
   * there is no failure.
   * 
   * @param alg  the algebra, assumed to be idempotent
   * @param report
   * @return x0, x1, y0 and y1 in alg that witness the failure or null if there is none
   */
  public static IntArray cpIdempotent(SmallAlgebra alg, ProgressReport report) {
    if (report != null) {
      report.addStartLine("Using Thm 5.1 of Freese-Valeriote to test if V(A) is SD-meet");
    }
    final int n = alg.cardinality();
    if (n == 1) {
      if (report != null) report.addEndingLine("the algebra has only one element so its variety is CP.");
      return null;
    }
    final BigProductAlgebra sq = new BigProductAlgebra(alg, 2);
    final IntArray a = new IntArray(2);
    final IntArray b = new IntArray(2);
    final IntArray c = new IntArray(2);
    final List<IntArray> gens = new ArrayList<IntArray>(3);
    gens.add(a);
    gens.add(b);
    gens.add(c);
    for (int x0 = 0; x0 < n; x0++) {
      for (int y0 = 0; y0 < n; y0++) {
        for (int x1 = 0; x1 < n; x1++) {
          for (int y1 = 0; y1 < n; y1++) {
            a.set(0, x0);
            a.set(1, y0);
            b.set(0, x0);
            b.set(1,y1);
            c.set(0,x1);
            c.set(1,y1);
            if (a.equals(b) || a.equals(c) || b.equals(c)) continue;
            final SmallAlgebra sub = new SubProductAlgebra("", sq, gens);
            final int aIndex = sub.elementIndex(a);
            final int bIndex = sub.elementIndex(b);
            final int cIndex = sub.elementIndex(c);
            Partition alpha = sub.con().Cg(aIndex, bIndex);
            Partition beta = sub.con().Cg(bIndex, cIndex);
            if (!alpha.compose(beta).isRelated(cIndex, aIndex)) {
              if (report != null) {
                report.setWitnessAlgebra(new AlgebraWithGeneratingVector(sub, 
                    new int[] {aIndex, bIndex, cIndex}));
                report.addLine("Found a failure of Theorem 5.1 of Freese-Valeriote");
                report.addLine("with x0 = " + x0 + ", y0 = " + y0 + ", x1 = " + x1 + ", y1 = " + y1);
                report.addEndingLine("This algebra does not generate a CP variety.");
              }
              return new IntArray(new int[] {x0,y0,x1,y1});
            }
          }
        }
      }
    }
    if (report != null) {
      report.addEndingLine("V(A) is congruence permutable.");
    }
    return null;
  }
  
  public static boolean fixedKPermIdempotent(SmallAlgebra alg, int level, ProgressReport report) {
    if (level < 2) throw new IllegalArgumentException("arity must be at least 3");
    final int n = level - 1;
    final int algSize = alg.cardinality();
    final int max = algSize - 1;
    if (report != null) {
      report.addStartLine("Test if the variety generated by " 
                          + alg.getName() + " is " + level + "-permutable.");
      report.addLine("using M. Valeriote and R. Willard, \"Idempotent n-permutable varieies,\"");
      report.addLine("Done when the size field get to " + algSize + "^" + level + " (or sooner if it fails).");
    }
    BigProductAlgebra algSq = new BigProductAlgebra(alg, 2);
    int[] A = new int[n + 1];
    ArrayIncrementor Ainc = SequenceGenerator.sequenceIncrementor(A, max);
    int count = 0;
    while (true) {
      if (Thread.currentThread().isInterrupted()) {
        if (report != null) report.addEndingLine("Test cancelled");
        return false;
      }
      if (report != null) report.setSize(count++);
      int[] B = new int[n + 1];
      ArrayIncrementor Binc = SequenceGenerator.sequenceIncrementor(B, max);
      while (true) {
        BinaryRelation R = BasicBinaryRelation.identity(algSize);
        for (int i = 1; i <= n; i++) {
          List<IntArray> gens = new ArrayList<IntArray>(3);
          gens = new ArrayList<IntArray>(3);
          gens.add(new IntArray(new int[] {A[i-1], A[i]}));
          gens.add(new IntArray(new int[] {B[i-1], A[i]}));
          gens.add(new IntArray(new int[] {B[i-1], B[i]}));
          Closer closer = new Closer(algSq, gens);
          closer.setSuppressOutput(true);
          //System.out.println("i: " + i);
          List<IntArray> sub = closer.sgClose();
          R = R.compose(new BasicBinaryRelation(sub, algSize));
          //System.out.println("R now is " + R);
        }
        if (!R.isRelated(A[0], B[n])) {
          if (report != null) {
            report.addLine("The test failed at A: " +Arrays.toString(A) + " and B: " + Arrays.toString(B));
            report.addEndingLine("The variety generated by " + alg.getName() 
                + " is not " + level + "-permutable.");
          }
          else {
            System.out.println("A: " + Arrays.toString(A));
            System.out.println("B: " + Arrays.toString(B));
          }
          return false;
        }
        if (!Binc.increment()) break;
      }
      if (!Ainc.increment()) break;
    }
    if (report != null) report.addEndingLine("The variety generated by " 
                         + alg.getName() + " is " + level + "-permutable.");
    return true;
  }
  
  /**
   * The variety generated by the algebra must be k-permutable for
   * some k or this won't ever stop.
   * 
   * @param alg
   * @param report
   * @return  the level of permutabilty of the variety
   */
  public static int permLevelIdempotent(SmallAlgebra alg, ProgressReport report) {
    final int algSize = alg.cardinality();
    final int max = algSize - 1;
    if (report != null) {
      report.addStartLine("Find the level of permutability of the variety generated by " + alg.getName());
      report.addLine("using M. Valeriote and R. Willard, \"Idempotent n-permutable varieies,\"");
      //report.addLine("Done when the size field get to " + algSize + "^" + level + " (or sooner if it fails).");
    }
    int n = 1;
    BigProductAlgebra algSq = new BigProductAlgebra(alg, 2);
    int[] A = new int[n + 1];
    ArrayIncrementor Ainc = SequenceGenerator.sequenceIncrementor(A, max);
    int count = 0;
    while (true) {
      if (Thread.currentThread().isInterrupted()) {
        if (report != null) report.addEndingLine("Test cancelled");
        return -1;
      }
      if (report != null) report.setSize(count++);
      int[] B = new int[n + 1];
      ArrayIncrementor Binc = SequenceGenerator.sequenceIncrementor(B, max);
      while (true) {
        BinaryRelation R = BasicBinaryRelation.identity(algSize);
        for (int i = 1; i <= n; i++) {
          List<IntArray> gens = new ArrayList<IntArray>(3);
          gens = new ArrayList<IntArray>(3);
          gens.add(new IntArray(new int[] {A[i-1], A[i]}));
          gens.add(new IntArray(new int[] {B[i-1], A[i]}));
          gens.add(new IntArray(new int[] {B[i-1], B[i]}));
          Closer closer = new Closer(algSq, gens);
          closer.setSuppressOutput(true);
          //System.out.println("i: " + i);
          List<IntArray> sub = closer.sgClose();
          R = R.compose(new BasicBinaryRelation(sub, algSize));
          //System.out.println("R now is " + R);
        }
        if (!R.isRelated(A[0], B[n])) {
          n++;
          if (report != null) {
            report.addLine("The test failed at A: " +Arrays.toString(A) + " and B: " + Arrays.toString(B));
            report.addLine("So the variety generated by " + alg.getName() 
                + " is not " + n + "-permutable. Will try " + (n+1) + ".");
          }
          else {
            System.out.println("The test failed");
            System.out.println("A: " + Arrays.toString(A));
            System.out.println("B: " + Arrays.toString(B));
            System.out.println("The variety is not " +  n + "-permutable.");
          }
          int[] AA = new int[n+1];
          int[] BB = new int[n+1];
          System.arraycopy(A, 0, AA, 0, A.length);
          System.arraycopy(B, 0, BB, 0, B.length);
          A = AA;
          B = BB;
          Ainc = SequenceGenerator.sequenceIncrementor(A, max);
          Binc = SequenceGenerator.sequenceIncrementor(B, max);
          // Note: if A[n] = B[n] then [A[0], B[n]] is in R because
          // [A[0], A[n]] clearly is. Thus it is OK to skip the test
          // for A and B as they are at this point. 
        }
        boolean ok = incrementUntilSomeInequality(A, B, Binc);
        if (!ok) break;
      }
      if (!Ainc.increment()) break;
    }
    if (report != null) report.addEndingLine("The variety generated by " 
                         + alg.getName() + " is " + (n+1) + "-permutable.");
    else System.out.println("The variety generated by "  + alg.getName() 
                             + " is " + (n+1) + "-permutable.");
    return n+1;
  }
  
  private static boolean incrementUntilSomeInequality(int [] A, int[] B, ArrayIncrementor Binc) {
    boolean isMore = Binc.increment();
    if (!isMore) return false;
    while (true) {
      if (isEqualSomewhere(A, B)) {
        isMore = Binc.increment();
        if (!isMore) return false;
      }
      break;
    }
    return true;
  }
  
  // Work from the back since that changes more ofter with our
  // incrementors. 
  private static boolean isEqualSomewhere(int[] a, int[] b) {
    final int len = a.length;
    for (int i = len - 1; i >= 0; i--) {
      if (a[i] == b[i]) return true;
    }
    return false;
  }
  
  public static Term malcevTerm(SmallAlgebra alg) {
    return malcevTerm(alg, null);
  }
  
  /**
   * Find a Mal'cev term for (the variety generated by) this algebra or
   * null if there is it is not permutable.
   */
  public static Term malcevTerm(SmallAlgebra alg, ProgressReport report) {
    if (alg.cardinality() == 1)  return Variable.x;
    //if (alg.isIdempotent()) {
    //  if (findDayQuadrupleInSquare(alg, report) != null) {
    //    if (report != null) {
    //      report.addLine("there is no Maltsev term");
    //    }
    //    return null;
    //  }
    //}
    FreeAlgebra f2 = new FreeAlgebra(alg, 2, report);
    // ** Need to put in a test if the tables will fit in memory. **
    f2.makeOperationTables();
    //logger.info("f2 size is " + f2.cardinality());
    IntArray g0 = new IntArray(new int[] {0,0});
    IntArray g1 = new IntArray(new int[] {0,1});
    IntArray g2 = new IntArray(new int[] {1,1});
    List<IntArray> gens = new ArrayList<IntArray>(3);
    gens.add(g0);
    gens.add(g1);
    gens.add(g2);
    final HashMap<IntArray,Term> termMap = new HashMap<IntArray,Term>(3);
    termMap.put(g0, Variable.x);
    termMap.put(g1, Variable.y);
    termMap.put(g2, Variable.z);
    final IntArray yx = new IntArray(new int[] {1,0});
    BigProductAlgebra f2squared = new BigProductAlgebra(f2, 2);
    // the yx argument means stop if yx is found. 
    // of course we want something different if we want the shortest term.
    report.addStartLine("looking for (y,x) in the subalgebra of F(2)^2 generated by (x,x) (x,y), (y,y).");
    List<IntArray> sub = f2squared.sgClose(gens, termMap, yx, report);
    report.addEndingLine("done finding subalgebra of F(2)^2.");
    //logger.info("sub alg of f2 squared size is " + sub.size());
    if (sub.contains(yx)) return (Term)termMap.get(yx);
    return null;
  }
  
  
  public static Term majorityTerm(SmallAlgebra alg) {
    return majorityTerm(alg, null);
  }
  
  public static Term majorityTerm(SmallAlgebra alg, ProgressReport report) {
    if (alg.cardinality() == 1)  return Variable.x;
    //if (alg.isIdempotent()) {
    //  if (findDayQuadrupleInSquare(alg, report) != null) {
    //    if (report != null) {
    //      report.addLine("there is no majority term");
    //    }
    //    return null;
    //  }
    //}
    FreeAlgebra f2 = new FreeAlgebra(alg, 2, report);
    // ** Need to put in a test if the tables will fit in memory. ** 
    f2.makeOperationTables();
    //logger.info("f2 size is " + f2.cardinality());
    IntArray g0 = new IntArray(new int[] {0,0,1});
    IntArray g1 = new IntArray(new int[] {0,1,0});
    IntArray g2 = new IntArray(new int[] {1,0,0});
    List<IntArray> gens = new ArrayList<IntArray>(3);
    gens.add(g0);
    gens.add(g1);
    gens.add(g2);
    final HashMap<IntArray,Term> termMap = new HashMap<IntArray,Term>();
    termMap.put(g0, Variable.x);
    termMap.put(g1, Variable.y);
    termMap.put(g2, Variable.z);
    final IntArray xxx = new IntArray(new int[] {0,0,0});
    BigProductAlgebra f2cubed = new BigProductAlgebra(f2, 3);
    // the yx argument means stop if yx is found. 
    // of course we want something different if we want the shortest term.
    List<IntArray> sub = f2cubed.sgClose(gens, termMap, xxx, report);
    //logger.info("sub alg of f2 cubed size is " + sub.size());
    if (sub.contains(xxx)) return (Term)termMap.get(xxx);
    return null;
  }

  
  /**
   * Find a Pixley term for (the variety generated by) this algebra or
   * null if there is it is not arithmetical.
   * The algorithm looks at the subalgebra of F(x,y)^3 generated by
   * (x,x,y), (y,y,y), (y,x,x) and looks for (x,x,x).
   */
  public static Term pixleyTerm(SmallAlgebra alg) {
    return pixleyTerm(alg, null);
  }
  
  /**
   * Find a Pixley term for (the variety generated by) this algebra or
   * null if there is it is not arithmetical.
   * The algorithm looks at the subalgebra of F(x,y)^3 generated by
   * (x,x,y), (y,y,y), (y,x,x) and looks for (x,x,x).
   */
  public static Term pixleyTerm(SmallAlgebra alg, ProgressReport report) {
    if (alg.cardinality() == 1)  return Variable.x;
    if (alg.isIdempotent()) {
      if (!isCongruenceDistIdempotent(alg, report)) {
        if (report != null) report.addLine("there is no Pixley term");
        return null;
      }
    }
    FreeAlgebra f2 = new FreeAlgebra(alg, 2, report);
    // ** Need to put in a test if the tables will fit in memory. **
    f2.makeOperationTables();
    //logger.info("f2 size is " + f2.cardinality());
    IntArray g0 = new IntArray(new int[] {0,0,1});
    IntArray g1 = new IntArray(new int[] {1,1,1});
    IntArray g2 = new IntArray(new int[] {1,0,0});
    List gens = new ArrayList(3);
    gens.add(g0);
    gens.add(g1);
    gens.add(g2);
    final HashMap termMap = new HashMap();
    termMap.put(g0, Variable.x);
    termMap.put(g1, Variable.y);
    termMap.put(g2, Variable.z);
    final IntArray xxx = new IntArray(new int[] {0,0,0});
    BigProductAlgebra f2cubed = new BigProductAlgebra(f2, 3);
    // the yx argument means stop if yx is found. 
    // of course we want something different if we want the shortest term.
    List sub = f2cubed.sgClose(gens, termMap, xxx, report);
    //logger.info("sub alg of f2 cubed size is " + sub.size());
    if (sub.contains(xxx)) return (Term)termMap.get(xxx);
    return null;
  }

  public static List<Term> hagemannMitschkeTerms(SmallAlgebra alg) {
    return hagemannMitschkeTerms(alg, null);
  }
  
  /**
   * This returns a list of Hagemann Mitschke Terms terms witnessing 
   * <code>k</code>-permutability, or
   * null if the algebra does generate a congruence 
   * <code>k</code>-permutable variety.
   * It is guarenteed to be the least number of terms possible.
   */
  public static List<Term> hagemannMitschkeTerms(SmallAlgebra alg, ProgressReport report) {
    if (report != null) report.addStartLine("finding Hagemann-Mitschke terms.");
    List ans = new ArrayList<Term>();
    if (alg.cardinality() == 1) {
      ans.add(Variable.x);
      ans.add(Variable.z);
      return ans;
    }
    FreeAlgebra f2 = new FreeAlgebra(alg, 2, report);
    // ** Need to put in a test if the tables will fit in memory. **
    f2.makeOperationTables();
    //logger.info("f2 size is " + f2.cardinality());
    IntArray g0 = new IntArray(new int[] {0,0});
    IntArray g1 = new IntArray(new int[] {0,1});
    IntArray g2 = new IntArray(new int[] {1,1});
    List gens = new ArrayList(3);
    gens.add(g0);
    gens.add(g1);
    gens.add(g2);
    final HashMap termMap = new HashMap(3);
    termMap.put(g0, Variable.x);
    termMap.put(g1, Variable.y);
    termMap.put(g2, Variable.z);
    final IntArray yx = new IntArray(new int[] {1,0});
    BigProductAlgebra f2squared = new BigProductAlgebra(f2, 2);
    // the yx argument means stop if yx is found. 
    // of course we want something different if we want the shortest term.
    if (report != null) report.addStartLine("finding the subalgebra of F(2)^2 generated by (x,x), (x,y), (y,y)");
    List sub = f2squared.sgClose(gens, termMap, yx, report);
    if (report != null) report.addEndingLine("subalgebra size = " + sub.size());
    //logger.info("sub alg of f2 squared size is " + sub.size());
    if (sub.contains(yx)) {
      if (report != null) report.addLine("The variety has a Maltsev term: " + termMap.get(yx));
      //logger.info("this variety has a Malcev term");
      ans.add(Variable.x);
      ans.add(termMap.get(yx));
      ans.add(Variable.z);
      return ans;
    }
    // Not sure we need this. Check if we need to sort this.
    Comparator c = new Comparator() {
        public int compare(Object o1, Object o2) {
          IntArray ia1 = (IntArray)o1;
          IntArray ia2 = (IntArray)o2;
          for (int i = 0; i < ia1.universeSize(); i++) {
            if (ia1.get(i) < ia2.get(i)) return -1;
            if (ia1.get(i) > ia2.get(i)) return 1;
          }
          return 0;
        }
        public boolean equals(Object o) { return false; }
    };
    Collections.sort(sub, c);
    final List path = hagemannMitschkeLevelPath(sub, g0, g2);
    if (path == null) {
      if (report != null) report.addEndingLine("this variety is not K-permutable");
      return null;
    }
    for (Iterator it = path.iterator(); it.hasNext(); ) {
      IntArray ia = (IntArray)it.next();
      ans.add(termMap.get(ia));
    }
    if (report != null) report.addEndingLine("Found the Hagemann-Mitschke terms.");
    return ans;
  }

  /**
   * This finds a path from g0 to g2 in <tt>middleZero</tt>, a list
   * of triples, where two triples are connected by an edge if either
   * their first or third coordinates agree.
   */
  public static List hagemannMitschkeLevelPath(List sub, IntArray g0, 
                                                         IntArray g2) {
    // a list of lists of IntArray's
    final List levels = new ArrayList();
    final Map parentMap = new HashMap();
    List currentLevel = new ArrayList();
    //final HashSet visited = new HashSet();
    currentLevel.add(g0);
    parentMap.put(g0, null);
    levels.add(currentLevel);
    Comparator c0 = new Comparator() {
        public int compare(Object o1, Object o2) {
          return ((IntArray)o2).get(0) - ((IntArray)o1).get(0);
        }
    };
    Comparator c2 = new Comparator() {
        public int compare(Object o1, Object o2) {
          return ((IntArray)o2).get(1) - ((IntArray)o1).get(1);
        }
    };
    HashMap classes0 = new HashMap();
    HashMap classes1 = new HashMap();
    for (Iterator it = sub.iterator(); it.hasNext(); ) {
      IntArray ia = (IntArray)it.next();
      Integer ia_0 = new Integer(ia.get(0));
      Integer ia_1 = new Integer(ia.get(1));
      List eqclass = (List)classes0.get(ia_0);
      if (eqclass == null) {
        eqclass = new ArrayList();
        classes0.put(ia_0, eqclass);
      }
      eqclass.add(ia);
      eqclass = (List)classes1.get(ia_1);
      if (eqclass == null) {
        eqclass = new ArrayList();
        classes1.put(ia_1, eqclass);
      }
      eqclass.add(ia);
    } 
    while (true) {
      final List nextLevel = new ArrayList();
//System.out.println("current level size = " + currentLevel.size());
      for (Iterator it = currentLevel.iterator(); it.hasNext(); ) {
        IntArray ia = (IntArray)it.next();
        List eqclass;
        eqclass = (List)classes1.get(new Integer(ia.get(0)));
        for (Iterator it2 = eqclass.iterator(); it2.hasNext(); ) {
          IntArray ia2 = (IntArray)it2.next();
          if (!parentMap.containsKey(ia2)) {
            parentMap.put(ia2, ia);
            nextLevel.add(ia2);
          }
          if (ia2.equals(g2)) {
            final List path = new ArrayList(levels.size() + 1);
            path.add(g2);
            ia2 = (IntArray)parentMap.get(ia2);
            while (ia2 != null) {
              path.add(ia2);
              ia2 = (IntArray)parentMap.get(ia2);
            }
            Collections.reverse(path);
            //logger.fine("Hagemann Mitschke path");
            //for (Iterator iter = path.iterator(); iter.hasNext(); ) {
            //  logger.fine("" + iter.next());
            //}
            return path;
          }
        }
      }
      if (nextLevel.isEmpty()) break;    
      levels.add(nextLevel);
      currentLevel = nextLevel;
    }
    return null;
  }
  
  /**
   * This gives unary terms evaluating to the characteristic
   * functions of the one element subsets of alg; a term which
   * applied to these unit vectors gives the identity function; and
   * a binary term giving a semilattice operation on {0, 1}. It is based on
   * D. M. Clark, B. A. Davey, J. G. Pitkethly and D. L. Rifqui, 
   * "Flat unars: the primal, the semi-primal, and the dualizable",
   * Algebra Universalis, 63(2010), 303-329.
   * 
   */
  public static List<Term> primalityTerms(SmallAlgebra alg, ProgressReport report) {
    Term semilatTerm = semilatTerm(alg, report);
    if (semilatTerm == null) return null;
    System.out.println("semilat term: " + semilatTerm);
    Term idTerm = idTerm(alg, report);
    if (idTerm == null) return null;
    System.out.println("id term: " + idTerm);
    List<Term> unitTerms = unitTerms(alg, report);
    if (unitTerms == null) return null;
    System.out.println("unit terms: " + unitTerms);
    List<Term> ans = new ArrayList<Term>(alg.cardinality() + 2);
    ans.add(semilatTerm);
    ans.add(idTerm);
    for (Term term : unitTerms) {
      ans.add(term);
    }
    return ans;
  }
  
  /**
   * Gives a binary term of alg that is a semilattice meet on 0 and 1 
   * or null if there is none. Used in testing primality.
   *  
   * @param alg
   * @param report
   * @return
   */
  private static Term semilatTerm(SmallAlgebra alg, ProgressReport report) {
    report.addStartLine("Looking for [0,0,0,1] (the meet operation) in A^4 generated by [0,0,1,1] and [0,1,0,1]."); 
    final BigProductAlgebra alg4 = new BigProductAlgebra(alg, 4);
    IntArray meet = new IntArray(new int[] {0,0,0,1});
    List<IntArray> gens = new ArrayList<IntArray>(2);
    gens.add(new IntArray(new int[] {0,0,1,1}));
    gens.add(new IntArray(new int[] {0,1,0,1}));
    Map<IntArray,Term> termMap = new HashMap<IntArray,Term>();
    termMap.put(gens.get(0), Variable.x);
    termMap.put(gens.get(1), Variable.y);
    Closer closer = new Closer(alg4, gens, termMap);
    closer.setProgressReport(report);
    closer.setElementToFind(meet);
    List<IntArray> lst = closer.sgClose();
    if (termMap.get(meet) == null) report.addEndingLine("Meet not found; the algebra is not primal.");
    else report.addEndingLine("A term for the meet is " + termMap.get(meet));
    return termMap.get(meet);
  }
  
  /**
   * Used in testing primality.
   */
  private static Term idTerm(SmallAlgebra alg, ProgressReport report) {
    final int n = alg.cardinality();
    report.addStartLine("Looking for the identity function on A in the subalgebra of A^" 
        + n + " generated by the unit vectors.");
    final BigProductAlgebra prod = new BigProductAlgebra(alg, n);
    List<IntArray> gens = new ArrayList<IntArray>(n);
    Map<IntArray,Term> termMap = new HashMap<IntArray,Term>();
    List<IntArray> units = unitVectors(n);
    final int[] idArr = new int[n];
    for (int i = 0; i < n; i++) {
      gens.add(units.get(i));
      termMap.put(units.get(i), new VariableImp("x_" + i));
      idArr[i] = i;
    }
    final IntArray id = new IntArray(idArr);
    Closer closer = new Closer(prod, gens, termMap);
    closer.setProgressReport(report);
    closer.setElementToFind(id);
    List<IntArray> lst = closer.sgClose();
    if (termMap.get(id) == null) report.addEndingLine("Id not found; the algebra is not primal.");
    else report.addEndingLine("A term for the Id is " + termMap.get(id));
    return termMap.get(id);
  }
  
  /**
   * Used in testing primality.
   */
  private static List<IntArray> unitVectors(int n) {
    List<IntArray> ans = new ArrayList<IntArray>(n);
    for (int i = 0; i < n; i++) {
      final int[] arr = new int[n];
      arr[i] = 1;
      final IntArray ia = new IntArray(arr);
      ans.add(ia);
    }
    return ans;
  }
  
  /**
   * Used in testing primality.
   */
  private static List<Term> unitTerms(SmallAlgebra alg, ProgressReport report) {
    final int n = alg.cardinality();
    report.addStartLine("Looking for terms giving the " + n + " units vectors in F(1).");
    List<IntArray> units = unitVectors(n);
    FreeAlgebra F = new FreeAlgebra(alg, 1, false, false, false, null, report);
    Closer closer = new Closer(F.getProductAlgebra(), F.generators(), F.getTermMap());
    closer.setProgressReport(report);
    closer.setElementsToFind(units, F.generators());
    closer.sgClose();
    if (!closer.allElementsFound()) {
      report.addEndingLine("Not all units were found. The algebra is not primal.");
      return null;
    }
    List<Term> ans = new ArrayList<Term>(n);
    for (IntArray ia : units) {
      ans.add(closer.getTermMap().get(ia));
    }
    report.addEndingLine("All units were found.");
    return ans;
  }
  
  /**
   * Find all TCT types occurring in subalgebras of <code>alg</code>.
   * 
   * @param alg    Assumed to be idempotent
   * @param report
   * @return
   */
  public static Set<Integer> typesInSofAIdempotent(SmallAlgebra alg, ProgressReport report) {
    Set typesFound = new TreeSet<Integer>();
    final int n = alg.cardinality();
    for (int a = 0; a < n; a++) {
      for (int b = a + 1; b < n; b++) {
        Subalgebra B = alg.sub().Sg(new int[]{a,b});
        int aInB = B.index(a);
        int bInB = B.index(b);
        final Partition one = B.con().one();
        if (!B.con().Cg(aInB, bInB).equals(one)) continue;
        if (!B.con().joinIrreducible(one)) continue;
        int type = B.con().typeJI(one, null); // suppress subtrace info
        if (report != null) {
          report.addLine("The congruence generated by " + a + " and " + b 
              + " in the subalgebra B generated by " + a + " and " + b
              + " 1_B is join irreducible with TCT type " + type);
        }
        typesFound.add(type);
      }
    }
    return typesFound;
  }
  
  /**
   * This finds two subsets of the set of types; the first is 
   * the types found in S(A) (so the types must contain this)
   * and a set of types such that the type set is contained in this.
   * 
   */
  public static List<Set<Integer>> typeSetIdempotent(SmallAlgebra alg, ProgressReport report){
    if (report != null) {
      report.addStartLine("Finding bounds for the type set of V(A).");
      report.addLine("The algorithm is based on M. Valeriote, "
          + "\"A subalgebra intersection property for congruence distributive varieties,\" "
          + "AU 61, (2009), 451-464, and ");
    }
    final Set<Integer> posibleTypes = new TreeSet<Integer>();
    for (int i = 1; i <= 5; i++) posibleTypes.add(i);
    List<Set<Integer>> ans = new ArrayList<Set<Integer>>(2);
    Set upper = new TreeSet<Integer>();
    Set typesFound = typesInSofAIdempotent(alg, report);
    ans.add(typesFound);// first part of the pair is typesFound 
    Set omitted = omittedIdealIdempotent(alg, typesFound, report);
    Set<Integer> types12 = new TreeSet<Integer>();
    types12.add(1);
    types12.add(2);
    if (typesFound.contains(1)) {
      if (typesFound.size() == 1) {
        ans.add(typesFound);
      }
      else {
        if (typesFound.contains(2) && typesFound.size() == 2) {  // found 1 and 2 only
          ans.add(types12);
        }
        else {
        ans.add(posibleTypes);
        }
      }
    }
    else {
      if (typesFound.contains(2) && typesFound.size() == 1) { // only 2 found so type set is at most 1,2
        ans.add(types12);
      }
      else {
        if (omitted.contains(5)) { // since it is an ideal and has 5, it has 1
          if (congruenceModularForIdempotent(alg, report)) {
            if (report != null) {
              report.addLine("This algebra lies in a CM variety. By ");
              report.addLine("R. Freese, \"Subdirectly irreducible algebras in modular varieties,\" "
                  + "Springer Lecture notes in Mathematics, 1004, 142-152,");
              report.addLine("the type set of V(A) equals that of S(A) in a CM variety.");
            }
            ans.add(typesFound);
          } 
          else {
            if (report != null) report.addLine("This algebra does not lie in a CM variety.");  
          }
        }
        else {
          posibleTypes.removeAll(omitted);
          ans.add(posibleTypes);
        }
      }
    }
    if (report != null) report.addEndingLine("type set includes " + ans.get(0) 
        + " is contained in " + ans.get(1) + ".");
    return ans;
  }
  
  
  /**
   * The largest order ideal of the poset of TCT types omitted by the 
   * variety generated by <code>alg</code>.
   * 
   * 
   * @param alg
   * @param typesFound   the types found in subalgebras of <code>alg</code>.
   * @param report
   * @return
   */
  public static Set<Integer> omittedIdealIdempotent(SmallAlgebra alg, Set<Integer> typesFound, 
      ProgressReport report) {
    Set<Integer> ans = new TreeSet<Integer>();
    if (!typesFound.contains(1)) {
      ans.add(1);
      if (!typesFound.contains(2)) ans.add(2);
      if (!typesFound.contains(5)) {
        ans.add(5);
        if (!typesFound.contains(4)) {
          ans.add(4);
          if (!typesFound.contains(3)) ans.add(3);
        }
      }
    }
    return ans;
  }
  
  /**
   * The largest order ideal of the poset of TCT types omitted by the 
   * variety generated by <code>alg</code>.
   * 
   */
  public static Set<Integer> omittedIdealIdempotent(SmallAlgebra alg, ProgressReport report) {
    if (report != null) {
      report.addStartLine("Finding the largest order ideal of omitted types in V(A).");
    }
    Set typesFound = typesInSofAIdempotent(alg, report);
    Set omittedIdeal = omittedIdealIdempotent(alg, typesFound, report);
    if (report != null) {
      report.addLine("The types found in subalgebras of A are " + typesFound + ".");
      report.addEndingLine("The largest ideal of omitted types in V(A) is " + omittedIdeal + ".");
      report.addLine("The algorithm is based on M. Valeriote, "
          + "\"A subalgebra intersection property for congruence distributive varieties,\" "
          + "AU 61, (2009), 451-464, and ");
      report.addLine("Freese and Valeriote, "
          + "\"On the complexity of some {M}altsev conditions\", IJAC 19 (2009), 41-77.");
    }
    return omittedIdeal;
  }
  
  

  
  
  static boolean foo = true;
  public static void main(String[] args) throws Exception {
    SmallAlgebra pol = org.uacalc.io.AlgebraIO.readAlgebraFile("/home/ralph/Java/Algebra/algebras/3polidpent2.ua");
    //System.out.println(fixedKPermIdempotent(pol, 3, null));
    //System.out.println(fixedKPermIdempotent(pol, 4, null));
    System.out.println(permLevelIdempotent(pol, null));
    
    if (foo) return;
    SmallAlgebra alg = null;
    try {
      if (args.length > 0) 
        alg = org.uacalc.io.AlgebraIO.readAlgebraFile(args[0]);
      else 
        alg = org.uacalc.io.AlgebraIO.readAlgebraFile(
            //"/home/ralph/Java/Algebra/algebras/wm3.ua"
            "/home/ralph/Java/Algebra/algebras/n5.ua"
            //"/home/ralph/Java/Algebra/algebras/3polidpent2.ua"
            //"/home/ralph/Java/Algebra/algebras/forkprime.ua"
       //     "/home/ralph/Java/Algebra/algebras/directoidNonCom7.ua"  /////////////////////
            //"/Users/ralph/Documents/algebras/tournamentSink.ua"
            //"/home/ralph/Java/Algebra/algebras/FivePaper.ua"
            //"/home/ralph/Java/Algebra/algebras/linjon4.ua"  // has a wnu term with x \circ y = y \circ x
            //"/home/ralph/Java/Algebra/algebras/linjon3.ua" // has no wnu term with x \circ y = y \circ x
                                                           // in fact x <-> y in F(x,y) has no fixed point 
            //"/Users/ralph/Documents/algebras/Polin.ua" 
            //"/home/ralph/Java/Algebra/algebras/polin.ua"
            //"/Users/ralph/Documents/algebras/A2new.ua"
        );
    }
    catch (Exception e) { 
      e.printStackTrace();
      return;
    }
    boolean ans = nuTermIdempotent(alg, 6, null);
    System.out.println("ans is " + ans);
    if (foo) return;
    
    Set ideal = omittedIdealIdempotent(alg, null);
    List types = typeSetIdempotent(alg, null);
    System.out.println("Omitted ideal is " + ideal);
    System.out.println("types  " + types);

    if (foo) return;
    //Term term = markovicMcKenzieSiggersTaylorTerm(alg, null);
    //System.out.println("term = " + term);
    
    Term wnu = findWeakNUTerm(alg, 3, null);
    System.out.println("wnu: " + wnu);
    
    if (true) return;
    
    List<Term> sdm = sdmeetTerms(alg, null);
    System.out.println("SD-meet terms = " + sdm);
    
    List<Term> sdTerms = sdTerms(alg, null);
    System.out.println("SD terms = " + sdTerms);
    
    
    //IntArray ia = findDayQuadrupleInSquare(alg, null);
    //System.out.println("day quad is " + ia);
    //System.out.println("congr mod var = " + congruenceModularVariety(alg));
    //List<Term> foo = primalityTerms(alg, null);
    //List<Term> foo = jonssonTerms(alg);
    //System.out.println("terms are " + foo);
    /*
    if (args.length == 0) return;
    SmallAlgebra alg0 = null;
    int arity = 3;
    try {
      alg0 = (SmallAlgebra)org.uacalc.io.AlgebraIO.readAlgebraFile(args[0]);
      if (args.length > 1) {
        arity = Integer.parseInt(args[1]);
      }
    }
    catch (Exception e) {}
    //int level = Malcev.jonssonLevel(alg0);
    //System.out.println("level is " + level);

    //Term t = findNUF(alg0, arity);
    //if (t == null) System.out.println("there is no NUF with arity " + arity);
    //else System.out.println("the alg has a NUF of arity " + arity + ": " + t);

    //IntArray ia = findDayQuadrupleInSquare(alg0);
    //System.out.println("day quad is " + ia);
    System.out.println("congr mod var = " + congruenceModularVariety(alg0));
    */
  }



}







